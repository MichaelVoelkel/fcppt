[section boost replacements]

[section noncopyable]
boost provides `boost::noncopyable` but it requires
that you either derive from it or aggregate it as a member.
Deriving can lead to conversion to `boost::noncopyable` by accident
or it can generate spurious warnings if you derive more than once
in a hierarchy.
Aggregating it as a member is also a bad idea because the empty base class optimization
cannot be used anymore and `boost::noncopyable` will take up at least one byte.
fcppt instead provides the macro `FCPPT_NONCOPYABLE`.
[note Because the macro has to make the copy constructor and the assignment operator
inaccessible, it will leave a private: scope after its declaration.]

[import ../examples/noncopyable.cpp]

[noncopyable]

There is also `FCPPT_NONASSIGNABLE` that just makes the assignment operator inaccessible.

[xinclude doxygen_noncopyable.xml]

[endsect]

[section Optional]
`fcppt::optional` is a replacement for `boost::optional`.
It simply doesn't use a union trick that leads to undefined behaviour.
If boost stops doing that, we might consider to use `boost::optional` again.

An optional, unlike a pointer, holds its optional object by value.
This also means that an optional has an additional size overhead if the value
is actually absent, but it doesn't require free store.

[import ../examples/optional.cpp]

[optional]

[xinclude doxygen_optional.xml]

[endsect]

[section Variant]
`fcppt::variant` is a replacement for `boost::variant`.
Unlike `boost::variant` it also doesn't use an undefined union trick.
There are, however, several other differences.

* Proper separation of the headers. Each functionality resides in its own header file.
* `fcppt::variant::object` can be empty. It doesn't require its first type to be default constructible.
* `fcppt::variant` reuses `boost::mpl sequences` to abstract the types that it can hold, so we have less code duplication.
* A ternary visitation is supplied. The whole visitation algorithms could be refactored to be n-ary, but a ternary
  visitation already has severe impact on compile time.

[section A simple example]

[import ../examples/variant.cpp]

[variant]

[endsect]

[section A recursive variant]

Like `boost::variant` fcppt provides a wrapper for a recursive variant.
If a variant can (indirectly) hold itself again, a problem arises.
The variant class has to know all of its members' sizes. But until the variant
is completely declared, its own size cannot be known.
To remedy this situation, you have to wrap a variant inside a struct,
which in turn has to be wrapped inside `fcppt::variant::recursive`.
Almost all algorithms on a variant will behave as if the `recursive` struct wasn't there.

[import ../examples/recursive_variant.cpp]

[recursivevariant]

[endsect]

[xinclude doxygen_variant.xml]

[endsect]

[endsect]
