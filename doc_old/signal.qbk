[section Signal]

[section Motivation]

Boost provides `boost::signals` for handling signals.
The biggest problem of `boost::signals` is that it is incredibly slow.
Benchmarking a large library revealed that most of the performance goes into calling the boost signals.
The same code with `fcppt::signal` had a significant performance advantage,
which is achieved by using `boost::intrusive::list` internally to store the connections for every signal.
Also, `fcppt::signal` now has some additional features, like combiners and deregistration notification.
However, it is not thread safe as `boost::signals2` is.
A small example shows its usage:

[import ../examples/signal/simple.cpp]
[signal_simple]

[endsect]

[section Combiners]

Signals can have return values.
If you attach more than one callback to such a signal,
one has to have a way of combining the return values of the callbacks to one single return value.
This is achieved with what we call "combiners".
A signal with a return value gets a combiner and an initial value called `initial_result` in its constructor.
If the signal's return type is `T` then the combiner must have the signature `T (T, T)`.
So a combiner gets the current combined value and the value returned from the current function called
from which it calculates a new combined value.

The detailed semantics are as follows:

# The computation starts with `initial_result`.
# For every registered function `current_combined = combine(current_combined, function());` will be executed.
# If there are no more functions left to call, `current_combined` will be returned.

This is what functional languages call /folding/
(see [@http://en.wikipedia.org/wiki/Fold_(higher-order_function) this Wikipedia entry]
for more information).

Here is an example:

[import ../examples/signal/combine.cpp]
[signal_combine]

[endsect]

[section Connections]

`fcppt::signal::object::connect` returns an `auto_connection`
which is a `unique_ptr` to some internal type.
Also, `fcppt::signal::scoped_connection` and `fcppt::signal::shared_connection`
which are scoped pointers or shared pointers to this internal type, respectively, are provided.
Additionaly, there is `fcppt::signal::connection_manager` that can aggregate `shared_connection`s.
This is most useful if you want to store all the connections at once in `connection_manager`.

[import ../examples/signal/connection.cpp]
[signal_connection]

[endsect]

[section Unregister notification]

Sometimes it is necessary to know when a connection previously returned from
a connect call is destroyed.
This can be done by using `fcppt::signal::unregister::base`.
The connect function of the `fcppt::signal::object` will change to
`connect(function, unregister_callback)`. `unregister_callback` must be a
function or functor with the signature `void()`.
However, you can bind additional information inside the function call,
as shown in the next example.

[import ../examples/signal/unregister.cpp]

[signal_unregister]

[endsect]

[xinclude doxygen_signal.xml]

[endsect]
