[section Log]

[section Hello World]
Here is a first example that creates a logger and produces output.

[import ../examples/log/helloworld.cpp]
[loghelloworld]

In the first line of `main`, a logger object is constructed using the
`parameters::all` class to tell the logger that it will log to
`fcppt::io::cout`, have level `debug` and "below" enabled and
is enabled itself.

Note also that we used `fcppt::io::cout` as the "sink" for our logger. You can
insert any `fcppt::io::ostream` here, so you can log to a file or even to
multiple sources or to a web server (you might take a look at
[@http://www.boost.org/doc/libs/release/libs/iostreams/index.html boost::iostreams]
if you're interested in that).

Next, we output "Hello World" to the `logger` object on its debug stream.
There are several log levels available:

# Verbose
# Debug
# Info
# Warning
# Error
# Fatal

These levels are ordered in the following way:

The `level::debug` parameter which we gave the logger in the example above is the
/second highest/ log level which is active (or enabled). All log levels /below/ this
level are also activated, so if you write: `.level(fcppt::log::level::debug)`,
then /all/ log levels except `verbose` are activated. If you write
`.level_defaults(fcppt::log::level::warning)` then the levels "warning", "error" and
"fatal" are activated - and so on with the other levels.

`level_defaults` is a shorthand to initialize all of the logger's sinks accordingly.
For simple use cases you do not have to know how different sinks behave.

Why do we use a macro for logging?
It expands roughly to the following:

``
if(logger.activated(fcppt::log::level::debug))
  do_the_logging();
``

Of course, this log syntax also is a bit awkward. Why not write something like:

``
logger_(fcppt::log::level::debug) << FCPPT_TEXT("Foobar");
``

And have the `operator()` return an object which does nothing if the `debug`
log level is not activated? The reason for that is performance: With the
method above, you have to evaluate the whole `operator<<` chain each time you
get to that line of code. This might be cheap when you only have a single
string to output, but if the information you want to transfer gets more
complex, it will cost you some computing time (definitely more than an `if()`
statement, anyway).

The (also a bit awkwardly looking) `fcppt::log::_` object is an output helper
object which basically forwards everything you give it via `operator<<` to the
underlying `fcppt::io::ostream`.

Note that the type of logger object construction basically follows the
[@http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.18 named parameter idiom].

[endsect]

[section Contexts]
Let's say you want to disable a specific logger via a command line parameter
while inside the `main()` function. Without further knowledge, the only
thing that comes to mind is calling the logger's `fcppt::log::logger::enable`
member function. But to do that, you need the logger object. It might be
extremely cumbersome to pass the logger object on from the `main` function
to wherever it is needed. That's
why each logger has a "location" which is a sequence of strings defining the
position of the logger in the logger hierarchy (the path down the logger tree,
so to speak).

A context is a class that can be given to a logger that has a location.
`parameters::with_context` is a shorthand to create such a logger.
It returns a `parameters::all` class so you can specify the other options
as well.
Let's look at an example:

[import ../examples/log/context.cpp]
[logcontext]

The logger context has an `apply` function to apply an action to loggers,
recursively starting at the specified location (note that the location is not
merely a string, but an own data type with an overloaded `operator/`
for concatenation).
The apply statement in the example will activate all loggers starting from
"::root" and beneath (so, root and child are both activated).
This can be used to enable or disable loggers or log levels at runtime in an easy way.

[note If the initialization becomes too cumbersome and repetitive, you can
create helper functions for that. That parameters::all is class can come in handy.]

[endsect]

[section A complex example]

The idea of a logger hierarchy is very natural in a big project. Small projects
might not need more than one or two independent loggers, but in a larger project
you usually have many different subsystems. For example, in a game engine you
would have a renderer subsystem, an input handler, a sound system and so on. All
of those can have different loggers so if something doesn't work, you can turn
them on incrementally and see where the error stems from.

What hasn't been mentioned yet is that the logger system is meant for global
logger objects. That's also why the loggers don't get their "parents" in the
hierarchy as objects, they merely get a path.

[note In C++ the order in which global objects in different translation
units are initialized is unspecified.]

To mitigate that problem, the loggers don't know each other. That also
leads to the very verbose initialization of each logger (you basically
have to repeat all the settings). In the following example we create a helper
function to avoid that.

[note The loggers have to know the global context. That's why its construction
is wrapped inside a macro which currently does nothing fancy but might in the
future.]

Another good thing about global loggers is that they will all be available when
the main function is entered. This also means that you can enable and disable
them right at the start of the program, which is what the next example does.

[import ../examples/log/complex.cpp]

[logcomplex]

[endsect]

[xinclude doxygen_log.xml]

[endsect]
