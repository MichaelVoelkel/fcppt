[section Math]

[section Overview]

math provides a set of utility classes and functions.

[variablelist

[[vector, dim and matrix]
[
These classes are very similar to each other.
Each of them can be statically or dynamically sized, which means that you can
either have a vector with a fixed amount of components (x, y and z, for
example) or one with a dynamic amount of components.
The classes provide simple constructors, getters, setters and arithmetic
operations and conversions. They also make proper use of operator overloading.
]]

[[sphere and box]
[
These classes offer wrappers around statically sized
spheres and boxes.
]]

[[free functions]
[
There are a lot of free utility functions like
float comparison, pi, absolute difference, and so on.
Most of these utility functions deal with abstractions
of floats and other integral types.
]]

]

[endsect]

[section Linear Algebra Classes]

fcppt has three classes for linear algebra:

* vector
* dim
* matrix

They all provide the following:

* A typedef struct exists for declaring a static or a dynamic class, called `static_` (note the underscore because `static` is already a keyword) and `dynamic` respectively.
* Variadic constructors up to an implementation defined size.
* Copy constructors and assignment operators.
* Iterators, `begin`, `end`, and so on.
* Access to elements via `operator[]` or `at()`.
* Equality and inequality comparison.

The templates vector and dim are actually /very/ similar and you might wonder
why they even exist! We've talked about this topic a long time. What it came
down to was: We don't want to accidentally type something like

``
vector2 v(x,y),m;
dim2 d(w,h);

// Here, m was meant instead of d
vector2 a = v + d;
``

Errors like this happen, and they're prevented by strictly separating
dimensions from vectors. Another approach would be even more strict: To
separate points from direction vectors. Some libraries do that. We, however,
thought of this as too strict and drew the line. It's still a bit disputed,
though. If there are strong arguments for further separation, we're open for
it. 

Keep in mind, though, that most arithmetic operations, like taking the dot
product, are not available for dim. You have to convert to a vector using
`structure_cast`.

[section Vector and Dim]

The following example shows how to declare
static and dynamic vectors. Note that dim
works almost the same.

[caution Because C++03 doesn't support 'template typedefs',
`static_` and `dynamic` are structs that use a nested
typedef called `type`. If you get strange errors with some math code, be sure
to look if you've omitted the `::type` at the end.]

[import ../examples/math/vector/basic.cpp]

[vectorbasic]

A lot of arithmetic operations are defined on vector and dim. Most of them are
element-wise operations. Some operations are free functions where they
theoretically could be member functions (like calculating the dot product).
We've mostly decided to make them free functions to reduce dependencies.

[import ../examples/math/vector/arithmetic.cpp]

[vectorarithmetic]

All linear algebra classes support a set of conversion functions.

* `structure_cast` can be used to do a `static_cast` on each element.
* `narrow_cast` can be used to cast a vector/dim to a vector/dim of a lower dimension. This is defined only for statically sized vectors.
* `construct` is the dual of `narrow_cast`.

[import ../examples/math/vector/convert.cpp]

[vectorconvert]

vector also provides named accessors.  They are called x, y, z and w
respectively.  For dim, they are called w, h and d. If you have vectors or dims
with a higher dimension than 3 (4 for vectors, obviously), you have to use
`at()` or `operator[]` to access the higher components.

[note If you try to access them out of bounds, you will get a compiler error for
static vectors or dims. But for dynamic vectors or dims, this is undefined.]

[import ../examples/math/vector/access.cpp]

[vectoraccess]

[endsect]

[section matrix]
matrix is a bit different from vector and dim because it is two-dimensional.

A matrix is most useful to describe affine transformations.
So, naturally, a matrix can be multiplied by a vector and a scalar.

[note Advanced features such as lazy matrix operations are not implemented right
now - simply because we didn't need those yet. If you're interested in extending
`fcppt::math`, contact us.]

For starters, here is a small example showing a few matrix features:

[import ../examples/math/matrix.cpp]

[matrixtransform]

[section Indices]

Matrices in fcppt have the `operator[]` defined so you can extract individual
cells as well as columns (extracting rows is not supported right now). A note
of caution, though: Matrix indices are of the form: (column, row), /not/
(row,column) as you might be used to from, well, all of mathematics for
example. Think of the indices as being coordinates in a grid. Here, you would
write (x,y) instead of (y,x), wouldn't you? :)

That being said, here is a very small example showing how to index a matrix:

[import ../examples/math/matrix_indices.cpp]

[matrixindices]

[endsect]

[section Matrix operations]

As said above, matrices will often be used to represent affine transformations.
Thus, most of the standard affine operations are included in
fcppt::math::matrix, as well as the usual matrix operations, as such:

[variablelist Transformations
 [[Translation] [This, of course, takes a vector as its argument]]
 [[Scaling] []]
 [[Rotation] [There are functions available for each of the three axes as well as rotation around an arbitrary axis through the origin]]
 [[Determinant] [This is not yet specialized for dimensions < 4, so it might be quite slow.]]
 [[Inverse] [Is calculated using the determinant and the adjunct matrix, so it's quite slow, see determinant]]
]

Note that all of these operations are implemented as free functions in their own header file.

[endsect]

[endsect]

[section Quaternion]

The `fcppt::math::quaternion` part is actually just a small wrapper around
`boost::math::quaternion` so you can construct quaternions from fcppt vectors
and convert a quaternion to an fcppt matrix. Apart from that, there are a few
utility functions like `normalize`, which normalizes a quaternion, and
`vector_rotation` which rotates an (fcppt) vector using a quaternion. See the
reference for more details.

[endsect]

[section Design rationale]

The linear algebra classes are designed in such a way that almost no extra code
is needed to implement statically and dynamically sized classes together.  This
is achieved by splitting every class into at least three template components:

* The value type to hold,
* The dimension type which can be either static or a placeholder for a dynamic type,
* The storage type to hold the elements.

Because the size and the storage type are orthogonal, it is possible to create
view types (which matrix already uses internally).

However, the static and dynamic typedefs as shown in earlier examples should be
enough for the casual user.

[endsect]

[endsect]

[section Geometric Classes]

Currently fcppt provides two simple geometric classes:

* sphere - An n-dimensional sphere
* box - An n-dimensional box

An example for box follows. Note that sphere is very similar.

[import ../examples/math/box.cpp]

[mathbox]

[endsect]

[section Utility Functions]

The free utility functions all reside in the header as their name implies.
For example fcppt::math::compare is in <fcppt/math/compare.hpp>.
Some examples follow.

[import ../examples/math/utility.cpp]

[section compare]
Compare can be used to compare floats and integral types alike.
[mathcompare]
[endsect]

[section power of 2]
is_power_of_2 checks if an unsigned integral type is a power of two.
[mathpowerof2]
[endsect]

[endsect]

[xinclude doxygen_math.xml]

[endsect]
