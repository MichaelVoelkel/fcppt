/**
\page goals Goals

<table id="toc">
<tr>
<td>

<ul>
	<li>\ref goals_cpp11</li>
	<li>\ref goals_fp</li>
	<li>\ref goals_types
		<ul>
			<li>\ref goals_types_fundamental</li>
			<li>\ref goals_types_typing</li>
		</ul>
	</li>
</ul>


</td>
</tr>
</table>

\section goals_cpp11 C++11

fcppt makes heavy use of C++11 to simplify code, improve performance and make
functional programming affordable. Consequently, almost every C++11 feature is
used somewhere which means that non-conforming compilers are not supported
(minus minor workarounds). For example, gcc-4.8 had a bug that made it
impossible to initialize references with the new initialization syntax. This is
easily worked around by using round instead of curly braces. On the other hand,
VC++ currently has too many fundamental issues you can't workaround that
easily. In the end, only gcc and clang provide enough C++11 support to work
with fcppt.

\section goals_fp Functional Programming

In C++11, functional programming has become efficient (move semantics
make it possible to cheaply return or pass on expressions) and
syntactically convenient (lambda functions can be used in-place
instead of defining a global function object). In functional
programming, everything is a value. Values are immutable and their
computations are notated by combining expressions instead of writing
out a sequence of statements. Although C++ is an imperative language
which has statements at the top, using functional programming can be
of great value to make code more understandable (by providing common
operations) and less error-prone (by directly initializing objects and
making them const, if possible).

An example where this becomes apparent is initializing a container, which is
almost impossible using only what C++11 offers directly. Most of the time you
end up using loops and initialize the container to the empty container. In
contrast, fcppt has a lot of common functional operations like \link
fcppt::algorithm::map Map\endlink, \link fcppt::algorithm::map_optional Map
Optional\endlink, \link fcppt::algorithm::map_concat Map Concat\endlink and
\link fcppt::algorithm::fold Fold\endlink which cover a lot of common cases of
initializing a container.

Functional programming also goes hand in hand with \link
goals_types better types\endlink, for example the above mentioned
\link fcppt::algorithm::map_optional Map Optional\endlink, but also
\link fcppt::optional_bind Optional Bind\endlink and \link
fcppt::from_optional From Optional\endlink.

\section goals_types Types

C++ has a unique type system which is mostly statically typed, supports
parametric and ad-hoc polymorphism, and dependent types. It also allows for
type unsafe conversions, dynamic typing with object oriented programming and
usage of raw memory, and a lot of implicit conversions to mix and match
fundamental types. Some of these features, especially implicit conversions, are
undesirable and should be avoided. The following sections talk about how we can
use the strengths of C++'s type system to get more robust programs.

\subsection goals_types_fundamental Fundamental types

Fundamental types, like <code>int</code> and <code>float</code>, have very weak
typing. They implicitly convert into each other which is especially troublesome
because some of these conversions are implementation-defined or even undefined.
The primary countermeasure to take here is to enable as many warnings as
possible, for example <code>-Wconversion</code> and
<code>-Wsign-conversion</code> in gcc and clang. However, sometimes these
conversions are necessary and should be done explicitly in these cases (which
also inhibits warnings). The C++ language feature to do so is to use
<code>static_cast</code>. A fundamental issue with this approach is that
<code>static_cast</code> converts too many things and therefore an expression
using it has too broad a meaning. To resolve this issue, fcppt provides the
\link fcpptcasts casts module \endlink which provides cast functions that can
only convert subsets of what <code>static_cast</code> can, e.g. \link
fcppt::cast::int_to_float \endlink.

Another issue with fundamental types becomes apparent in function typing. To
illustrate the problem, consider the following function:

\code
void draw_text(string text,bool center_vertically,bool center_horizontally,int font_size);
\endcode

A function call looks like this

\code
draw_text("Hello World",true,false,15);
\endcode

This obviously has the major disadvantage of not being self-explanatory. You
might forget the order of the arguments or someone might change the function's
type. To resolve this issue, fcppt provides another very important concept:
\link fcpptstrongtypedef strong typedefs\endlink which are similar to other
concepts in functional programming languages like <code>newtype</code> in
Haskell. Strong typedefs provide another layer of type constructors so that a
function call ends up looking like this:

\code
draw_text("Hello World",center_vertically{true},center_horizontally{false},font_size{15});
\endcode

As an added bonus, strong typedefs don't implicitly convert to anything.

\subsection goals_types_typing Improved typing

A type, which is a syntatical entity, can be semantically thought of as the set
of all possible values having that type. The type checker ensures that we can
only use such values, e.g. you can't call a function taking a string with an
integer. As a general rule, a function taking a type <code>T</code> should be
able to work with any value that has type <code>T</code>. Function interfaces
with complicated preconditions like "if parameter one has value X, then
parameter two shouldn't have value Y" or "if parameter one has value -1, it is
treated as absent" should be avoided.

Having values which can be absent is a very common case that is covered by
\link fcpptoptional Optional\endlink. <code>optional<T></code> adds another
possible value to all values of <code>T</code> with the meaning "no value" and
is similar to <code>Maybe</code> in Haskell.

Complicated function interfaces often arise when completely different types can
be passed in, like "string or int". With very basic typing, this might be
handled with casts and a flags field which leads to very complicated and
error-prone function interfaces. \link fcpptvariant Variant\endlink is a class
that can encapsulate multiple types with the meaning of "any of", e.g.
<code>variant<vector<int,string>></code>.
*/
