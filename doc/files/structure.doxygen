/**
\page structure Structure

<table id="toc">
<tr>
<td>


<ol>
<li>
	\ref structure_file_separation
</li>
<li>
	\ref structure_coding_style
	<ol>
		<li>\ref structure_identifiers</li>
		<li>\ref structure_indentation
			<ol>
				<li>\ref structure_tabs</li>
				<li>\ref structure_when_to_indent</li>
			</ol>
		</li>
		<li>
		\ref structure_enums
			<ol>
				<li>\ref structure_bool_and_enums</li>
				<li>\ref structure_using_enums</li>
			</ol>
		</li>
		<li>
			\ref structure_code_partitioning
			<ol>
				<li>\ref structure_file_extension</li>
				<li>\ref structure_namespaces_and_directories</li>
				<li>\ref structure_atomic_headers</li>
				<li>\ref structure_minimal_includes</li>
				<li>\ref structure_include_guards</li>
			</ol>
		</li>
		<li>
			\ref structure_numerical_considerations
			<ol>
				<li>\ref structure_float_double_long_double</li>
				<li>\ref structure_integral_types</li>
			</ol>
		</li>
	</ol>
</li>
</ol>


</td>
</tr>
</table>

\section structure_file_separation File separation

Every function, typedef or class resides in its own header file. So, for
example, if you want to use fcppt::to_std_string (which is a function) you have
to <code>#include <fcppt/to_std_string.hpp></code>.

All classes have an additional fwd header, which only provides a declaration of
the class. For example <code><fcppt/type_info_fwd.hpp></code> provides the
declaration of fcppt::type_info and <code><fcppt/type_info.hpp></code> provides
the definition.

Template classes are split into three files. In addition to the
<code>_fwd</code> header there is a <code>_decl</code> header providing only
the class definition, as well as an <code>_impl</code> header providing the
method definitions. There is also a header with no suffix which includes the
three aforementioned headers. For example, the
fcppt::container::bitfield::basic class consists of the following files:

<ul>
<li>
	<code>
		fcppt/container/bitfield/basic_fwd.hpp
	</code>
</li>
<li>
	<code>
		fcppt/container/bitfield/basic_decl.hpp
	</code>
</li>
<li>
	<code>
		fcppt/container/bitfield/basic_impl.hpp
	</code>
</li>
<li>
	<code>
		fcppt/container/bitfield/basic.hpp
	</code>
</li>
</ul>

Using these separate headers might improve compile time, which is known to be a
problem for more complex template classes. You can, of course, just use the
non-suffixed header (<code>basic.hpp</code> in the example above) if you're not
concerned with compilation times.

\attention
If you forget to include the <code>_impl</code> header where the implementation
of a template is needed, you will get undefined references when linking.

Some sublibraries, like fcppt::math::vector, provide convenience headers that
include almost everything that belongs to the sub library. For example,
<code><fcppt/math/vector/vector.hpp></code> includes most of the headers found
under <code>fcppt/math/vector/</code>. Be aware, though, that this might
include a large number of (unnecessary) files and might slow down compilation
times.

\section structure_coding_style Coding style

\subsection structure_identifiers Identifiers

We use the same naming scheme as the C++ standard library. This means no camel
case, but all lowercase letters and underscores as separators
(<code>foo_bar_baz()</code> instead of <code>fooBarBaz()</code>). This way,
code which is mixed with boost and the standard library looks much more
consistent.

Macro names are <code>CAPTIALIZED</code> so they're not confused with normal
functions.

\note
The C standard library's <code>assert</code> function is a source for confusion
in this respect. You're not the only one if you tried to use it as:
\code
std::assert(0 < 1);
\endcode
Macros have no namespace scope.

\subsection structure_indentation Indentation

\subsubsection structure_tabs Tabs

We consistently use tabs instead of whitespaces for indentation. If you're
interested, here's why we do that:

Most coding guidelines just dismiss the tab issue by stating that you should
just use 'n' whitespaces for indentation. The problem with this is: What are
sensible values for 'n'? For example, vim's standard tab width is 8. But if you
use a small terminal, you might run out of space if you, for example, nest 3
<code>if</code> statements inside a function. So the code looks ugly on some
machines.

This is where tabs come in handy. They allow for a variable 'n', depending on
what you specify in your text editor. But there are pitfalls. For example,
consider your tab width is 4:

\code
int a = 3,
    b = 4;
\endcode

You (or your automatically refactoring editor) might be tempted to write this
as:

\code
int a = 3,
\tb = 4;
\endcode

Which — with <em>n</em>=4 — <em>looks</em> the same. But the problem with this
is obvious, if you set your tab width to 8, it looks like this:

\code
int a = 3,
        b = 4;
\endcode

It's broken. There are two ways to prevent his: You could use whitespaces in
this situation, which would work <em>if</em> you have a monospace font (which,
of course, most people do use when programming). If you don't, the following
happens:

int a = 3,<br>
&nbsp;&nbsp;&nbsp;&nbsp;b = 4;

The second solution is to indent it like this

\code
int
\ta=3,
\tb=4;
\endcode

Which is tab-safe and doesn't look too ugly, so that's what we're doing.

\subsubsection structure_when_to_indent When to indent

When to indent is pretty much left to the individual programmer. Specifying
more than a few encouragements would be pretty harsh. A rule of thumb for us is
"indent as much as possible", which can be best explained by an example:

\code
template<
    typename T,
    typename U
>
T
cast_stuff(
    U const &a,
    U const &b)
{
    run_other_function
    (
        run_yet_another_function
        (
            static_cast
            <
                T
            >
            (
                a
            );
        )
    );
}
\endcode

This, at first glance, might look pretty odd to you, but it is something you
might encounter when reading fcppt code (Freundlich's code in particular :P).
This method of indentation is a bit extreme, but it is consistent: We insert a
newline after every opening brace (curly brace, parentheses, whatever).

\subsection structure_enums Enums

\subsubsection structure_bool_and_enums bool and enums

We encourage you to use bools very sparingly. To illustrate the problem with
bools, consider the function:

\code
void draw_text(string text,bool center_vertically,bool center_horizontally,int font_size);
\endcode

A function call looks like this

\code
draw_text("Hello World",true,false,15);
\endcode

Say you wrote this line and, weeks later, you open it again. Do you remember
what the 'true' and 'false' are for? And if you remember that they are
controlling text alignment, which of the bools controls the vertical alignment
and which one controls the horizontal alignment?

You cannot deduce that from looking at the code, you have to look at the
declaration. There's another, more subtle, problem with this code. Say your
memory is tainted and you think you have to specify the font size first, then
the alignment stuff, so you write:

\code
draw_text("Hello World",15,true,false);
\endcode

This code compiles without a warning with recent gcc and with all warnings
enabled. So you have a hard time refactoring because the compiler is of no
help. That's pretty much the reason bools are discouraged: You lose
information. bool is, however, useful with functions which really just give
"yes" or "no" as an answer such as:

\code
class life
{
public:
    bool has_meaning() const;
};
\endcode

In this example, you could either use an enum (see below) or \link
insert_link_to_strong_typedef_tutorial_here strong typedefs\endlink.

\subsubsection structure_using_enums Using enums

So how do we use enums in C++ properly? Without thinking further, you might
write your enums like this:

\code
enum shape
{
    circle,
    square,
    fridge
};
\endcode

You could then write functions which take this enum and do something with it:

\code
player_shape create(shape);
\endcode

And you'd call this function with:

\code
player_shape s = create(shape::circle);
\endcode

This code, however, doesn't compile. That's because enums do not open a new
namespace! Which is a problem, since they pollute the namespace they're defined
in. So we encourage a simple workaround:

\code
namespace shape
{
enum type
{
    circle,
    square,
    fridge,
    size
};
}
\endcode

Now the create function declaration and its call look like:

\code
player_shape create(shape::type);

create(shape::circle);
\endcode

Which is much better. Also note that we added a 'size' element at the end. This
way, we can use the enumeration together with
fcppt::container::bitfield::basic, or we could manually iterate over it.

\subsection structure_code_partitioning Code partitioning

\subsubsection structure_file_extension File extension

Many people use ".h" for their C++ header files. We encourage using ".hpp"
because that way your favorite editor can deduce that you're writing C++ code
and change, for example, the syntax highlighting accordingly.

\subsubsection structure_namespaces_and_directories Namespaces and directories

To avoid filename clashes we let the file system hierarchy follow the namespace
hierarchy. So a namespace creates a new directory - with nesting of directories
of course.

\subsubsection structure_atomic_headers Atomic headers

We encourage writing header files which contain only one "entity", so one
typedef, one class, one constant only. This way, it's very easy to memorize
which file you have to include to get a specific entity (for
<code>foo::bar::baz</code> you need <code>foo/bar/baz.hpp</code>, see
\ref structure_namespaces_and_directories above).

\subsubsection structure_minimal_includes Minimal includes

A header should only include what it needs so it can be included without
causing errors by itself. If code from the header is used, however, additional
includes may be needed.

In the following cases only a declaration is needed:

<ol>
	<li>A type is returned by a function or taken as an argument</li>
	<li>
	A typedef to a template is declared
	\code
template
<
  typename T
> struct vector;

typedef vector<char> char_vector;
	\endcode
	</li>
</ol>

TODO: Expand this!

\subsubsection structure_include_guards Include guards

It's extremely important for include guards to be unique. If they're not, you
end up in a long debugging session to find missing declarations or even
undefined references.

So we devised a simple scheme for the names: We use the complete namespace
hierarchy plus the suffix <code>_HPP_INCLUDED</code>, so consider this file:

\code
namespace sge
{
namespace gui
{
namespace buttons
{
class text
{
    ...
};
}
}
}
\endcode

The corresponding include guard would be:
<code>SGE_GUI_BUTTONS_TEXT_HPP_INCLUDED</code>.  This way, sensible behavior is
guaranteed. This, of course, requires that header files are quite atomic (see
\ref structure_atomic_headers above). If headers aren't really atomic, use the
(converted) file name as the include guard.

\subsection structure_numerical_considerations Numerical considerations

\subsubsection structure_float_double_long_double float/double/long double

The C++ standard states that basically all operations regarding floats are
implementation defined. This might lead to a "fatal error" in the following
code:

\code
float f = 1.0f;
if (f == 1.0f)
  do_something_safe();
else
  cause_fatal_error();
\endcode

float comparison is not only implementation defined, it's pretty "blurry" in
most implementations.

So you shouldn't use "strict" comparison. There's fcppt::math::compare and
fcppt::math::almost_zero which use the <a
href="http://en.wikipedia.org/wiki/Machine_epsilon">machine epsilon</a> for
comparison. This is, however, a bad choice in most cases. You might have to
write your own comparison function.

\subsubsection structure_integral_types Integral types

The use of the signed types is discouraged. Of course, sometimes you need to
use them to get negative numbers, but the signed types have a distinct
disadvantage: Some operations are undefined or implementation defined.

For example, the behavior of the % operator is partially implementation
defined.  Also, the value of <code>INT_MAX+1</code> is undefined, so you cannot
use ints to "wrap around" the borders. The unsigned types have such guarantees,
so use them if you really do not need negative numbers.
*/
