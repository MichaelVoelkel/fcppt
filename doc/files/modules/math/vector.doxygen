namespace fcppt
{
namespace math
{
/**
\brief Contains \link fcppt::math::vector::object vector::object \endlink and helper functions, classes and types for it
*/
namespace vector
{
}
}
}

/**
\defgroup fcpptmathvector fcppt.math.vector
\ingroup fcpptmath
\brief A class representing static n-dimensional vectors

<table id="toc">
<tr>
<td>

<ul>
	<li>\ref fcpptmathvector_introduction</li>
	<li>\ref fcpptmathvector_declaring_vectors</li>
	<li>\ref fcpptmathvector_init</li>
	<li>\ref fcpptmathvector_conversions</li>
	<li>\ref fcpptmathvector_null_vectors_and_comparisons</li>
	<li>\ref fcpptmathvector_operators</li>
	<li>\ref fcpptmathvector_headers</li>
</ul>

</td>
</tr>
</table>

\section fcpptmathvector_introduction Introduction

fcppt::math::vector::object is a statically sized n-dimensional array with the
usual vector operations like addition, scalar multiplication, and so on.
The signature consists of three template parameters:
\code
template<
	typename T,
	typename N,
	typename S
>
class vector;
\endcode
The first template parameter is the element type, while the second parameter is
an integral constant (like std::integral_constant) defining the vector's static
size. The third template parameter is the so called storage which usually is an
array of size <code>N::value</code>. However, S can be used to implement
various kinds of vectors, e.g. views with <code>S=T*</code>.

\section fcpptmathvector_declaring_vectors Declaring vectors

A normal vector owning its data can be declared as follows:

\snippet math/vector.cpp vector2f

This is abbreviated by a template alias:

\snippet math/vector.cpp vector2f_short

\section fcpptmathvector_init Initialization

An fcppt::math::vector::object<T,N,S> can be initialized by either:
<ul>
<li>fcppt::no_init,</li>
<li>N values of type T (up to the limit of FCPPT_MATH_VECTOR_MAX_CTOR_PARAMS),</li>
<li>a pair of iterators over an input range of type T and length N or</li>
<li>a value of type S.</li>
</ul>

\snippet math/vector.cpp init

Initializing by a value of type S is important for view vectors.

\section fcpptmathvector_conversions Conversions

fcppt::math::vector::object mostly behaves like the numeric type it
encapsulates. Conversions, however, must be done explicitly, e.g.  the
following code will not compile:
\code
fcppt::math::vector::static_<
	int,
	1
> const i(
	10
);

fcppt::math::vector::static_<
	float,
	1
> const f(
	i
);
\endcode

fcppt::math::vector::structure_cast is a function that converts between vector
types of the same dimension but which may differ in their value types. How
the value types are converted is specified by a function object.

\snippet math/vector.cpp convert

fcppt::math::vector::construct creates a vector of dimension N+1 from a vector
of dimension N. fcppt::math::vector::narrow_cast creates a vector of dimension
N-1 from a vector of dimension N by discarding the last element.

\snippet math/vector.cpp construct_narrow

\section fcpptmathvector_null_vectors_and_comparisons Null vectors and comparisons

To get a vector with all zeroes, use the static member function <code>::%null()</code>:

\snippet math/vector.cpp null

To compare two vectors, you <em>can</em> use the comparison operators:

\snippet math/vector.cpp comparison

This will use the float comparison operator. However, since floating point
values are inherently inaccurate, an exact comparison is almost <em>never</em>
what you want to do. Instead, you should use a different method for comparison.
For example, you could check if the Euclidean distance is small enough, using
fcppt::math::vector::length:

\snippet math/vector.cpp comparison_length

Or, you could test if none of the components exceeds the given epsilon, using
fcppt::math::range_compare:

\snippet math/vector.cpp comparison_range

\section fcpptmathvector_operators Operators

Including <strong><code>fcppt/math/vector/object_decl.hpp</code></strong> you
will get the following operators (<code>S2</code> defines some other storage
type):

<ul>
	<li><code>operator+=(vector::object<T,N,S2>)</code></li>
	<li><code>operator-=(vector::object<T,N,S2>)</code></li>
	<li><code>operator*=(vector::object<T,N,S2>)</code></li>
	<li><code>operator/=(vector::object<T,N,S2>)</code></li>
	<li><code>operator%=(vector::object<T,N,S2>)</code></li>
	<li><code>operator*=(T)</code> (multiply by a scalar)</li>
	<li><code>operator/=(T)</code> (divide by a scalar)</li>
	<li><code>operator=(dim::object const &)</code> (regular assignment operator)</li>
	<li><code>operator=(dim::object<T,N,S2> const &)</code></li>
	<li><code>operator[](size_type)</code></li>
</ul>

The arithmetic operators all work component-wise.

Including <strong><code>fcppt/math/vector/comparison.hpp</code></strong> you get all the comparison operators:

<ul>
	<li><code>operator==</code></li>
	<li><code>operator!=</code></li>
	<li><code>operator<=</code></li>
	<li><code>operator<</code></li>
	<li><code>operator>=</code></li>
	<li><code>operator></code></li>
</ul>

All of these work component-wise and forward to the <code>value_type</code>'s
operators. The ordering is lexicographic. This means that you can use a vector
with associative containers like <code>std::%set,std::%map,...</code>. Keep in
mind that the equality comparison operators do <em>not</em> use an epsilon so
you <em>will</em> get exact floating point comparisons (be sure that you really
want that!).

Including <strong><code>fcppt/math/vector/arithmetic.hpp</code></strong> gives
you the following operators:

<ul>
	<li><code>operator+(vector::object<T1,N,S>,vector::object<T2,N,S>)</code></li>
	<li><code>operator-(vector::object<T1,N,S>,vector::object<T2,N,S>)</code></li>
	<li><code>operator*(vector::object<T1,N,S>,vector::object<T2,N,S>)</code></li>
	<li><code>operator/(vector::object<T1,N,S>,vector::object<T2,N,S>)</code></li>
	<li><code>operator%(vector::object<T1,N,S>,vector::object<T2,N,S>)</code></li>
	<li><code>operator*(T1,vector::object<T2,N,S>)</code> (scalar multiplication)</li>
	<li><code>operator/(T1,vector::object<T2,N,S>)</code> (scalar division)</li>
	<li>Unary minus for vectors</li>
</ul>

The arithmetic operators all work component-wise. Note that
<code>operator*</code> does not denote the dot or cross product, but the
component-wise product. See fcppt::math::vector::dot and
fcppt::math::vector::cross.

It is important to note that all of the free operators support that the value
types of their arguments differ. Suppose we can divide meters by seconds to get
speed.

\snippet math/vector.cpp asymmetric_div_decl

This can now be used to divide vectors of meters by vectors of seconds to
obtain vectors of speeds.

\snippet math/vector.cpp asymmetric_div

Including <strong><code>fcppt/math/vector/input.hpp</code></strong> gives
you an <code>operator>></code> for reading input from standard streams.
Conversely, including
<strong><code>fcppt/math/vector/output.hpp</code></strong> gives you an inverse
<code>operator<<</code>.

Including <strong><code>fcppt/math/vector/dim.hpp</code></strong> gives you the
following operators:

<ul>
	<li><code>operator+(vector::object<T1,N,S1>,dim::object<T2,N,S2>)</code></li>
	<li><code>operator-(vector::object<T1,N,S1>,dim::object<T2,N,S2>)</code></li>
	<li><code>operator*(vector::object<T1,N,S1>,dim::object<T2,N,S2>)</code></li>
	<li><code>operator/(vector::object<T1,N,S1>,dim::object<T2,N,S2>)</code></li>
	<li><code>operator%(vector::object<T1,N,S1>,dim::object<T2,N,S2>)</code></li>
</ul>

Again, these work component-wise and have support for asymmetric argument types.

\section fcpptmathvector_headers Header files

fcppt::math::vector is spread out across various header files. There's one
header per free function. fcppt::math::vector::object itself is split into
various headers, too. Here's an exhaustive list:

<table>
<tr>
<th>Header file</th>
<th>Description</th>
</tr>
<tr>
<td><code>object_fwd.hpp</code></td>
<td>Contains \link fcppt::math::vector::object object's \endlink declaration. Include this if you pass a vector by reference, for example.</td>
</tr>
<tr>
<td><code>object_decl.hpp</code></td>
<td>Contains \link fcppt::math::vector::object object's \endlink definition.</td>
</tr>
<tr>
<td><code>object_impl.hpp</code></td>
<td>Contains the definition of \link fcppt::math::vector::object object's \endlink member functions.</td>
</tr>
<tr>
<td><code>object.hpp</code></td>
<td>Includes <code>object_fwd.hpp</code>, <code>object_decl.hpp</code> and <code>object_impl.hpp</code></td>
</tr>
<tr>
<td><code>arithmetic.hpp</code></td>
<td>Contains \link fcppt::math::vector::object object's \endlink arithmetic operators.</td>
</tr>
<tr>
<td><code>comparison.hpp</code></td>
<td>Contains \link fcppt::math::vector::object object's \endlink comparison operators.</td>
</tr>
<tr>
<td><code>input.hpp</code></td>
<td>Contains an <code>operator>></code> for the standard input streams (wide and narrow) which expects vectors to be input in the format: <code>(v1,v2,v3,...)</code></td>
</tr>
<tr>
<td><code>output.hpp</code></td>
<td>Contains an <code>operator<<</code> for the standard input streams (wide and narrow) which outputs vectors in the format: <code>(v1,v2,v3,...)</code></td>
</tr>
<tr>
<td><code>dim.hpp</code></td>
<td>Contains arithmetic operators to interoperate with the fcppt::math::dim::object class (see this class for more information)</td>
</tr>
</table>
*/
