namespace fcppt
{
namespace math
{
/**
\brief Contains \link fcppt::math::vector::object vector::object \endlink and helper functions, classes and types for it
*/
namespace vector
{
}
}
}

/**
\defgroup fcpptmathvector fcppt.math.vector
\ingroup fcpptmath
\brief A class representing static n-dimensional vectors

<table id="toc">
<tr>
<td>

<ul>
	<li>\ref fcpptmathvector_introduction</li>
	<li>\ref fcpptmathvector_declaring_vectors</li>
	<li>\ref fcpptmathvector_init</li>
	<li>\ref fcpptmathvector_conversions</li>
	<li>\ref fcpptmathvector_null_vectors_and_comparisons</li>
	<li>\ref fcpptmathvector_operators</li>
	<li>\ref fcpptmathvector_headers</li>
</ul>

</td>
</tr>
</table>

\section fcpptmathvector_introduction Introduction

\link fcppt::math::vector::object\endlink is a statically sized n-dimensional
array with the usual vector operations like addition, scalar multiplication,
and so on. The signature consists of three template parameters:
\code
template<
	typename T,
	fcppt::math::size_type N,
	typename S
>
class vector;
\endcode
The first template parameter is the element type, while the second parameter is
the vector's static size. The third template parameter is the so called storage
which usually is an array of size <code>N</code>. However, <code>S</code> can
be used to implement various kinds of vectors, e.g. views with
<code>S=T*</code>.

\section fcpptmathvector_declaring_vectors Declaring vectors

A normal vector owning its data can be declared as follows:

\snippet math/vector.cpp vector2f

This is abbreviated by a template alias:

\snippet math/vector.cpp vector2f_short

\section fcpptmathvector_init Initialization

An <code>fcppt::math::vector::object<T,N,S></code> can be initialized by
either:
<ul>
<li>\link fcppt::no_init\endlink,</li>
<li><code>N</code> values of type <code>T</code>,</li>
<li>or a value of type <code>S</code>.</li>
</ul>

\snippet math/vector.cpp init

Initializing by a value of type S is important for view vectors.

\section fcpptmathvector_conversions Conversions

\link fcppt::math::vector::object\endlink mostly behaves like the numeric type it
encapsulates. Conversions, however, must be done explicitly.
\link fcppt::math::vector::structure_cast\endlink is a function that converts
between vector types of the same dimension but which may differ in their value
types. How the value types are converted is specified by a function object.

\snippet math/vector.cpp convert

\link fcppt::math::vector::construct\endlink creates a vector of dimension
<code>N+1</code> from a vector of dimension <codE>N</code>. \link
fcppt::math::vector::narrow_cast\endlink creates a vector of dimension
<codE>N-1</code> from a vector of dimension <code>N</code> by discarding the
last element.

\snippet math/vector.cpp construct_narrow

\section fcpptmathvector_null_vectors_and_comparisons Null vectors and comparisons

To get a vector with all zeroes, use \link fcppt::math::vector::null\endlink:

\snippet math/vector.cpp null

To compare two vectors, you <em>can</em> use the comparison operators:

\snippet math/vector.cpp comparison

This will use the float comparison operator. However, since floating point
values are inherently inaccurate, an exact comparison is almost <em>never</em>
what you want to do. Instead, you should use a different method for comparison.
For example, you could check if the Euclidean distance is small enough, using
\link fcppt::math::vector::length\endlink:

\snippet math/vector.cpp comparison_length

Or, you could test if none of the components exceeds the given epsilon, using
\link fcppt::math::vector::componentwise_equal\endlink:

\snippet math/vector.cpp comparison_range

\section fcpptmathvector_operators Operators

<strong><code>fcppt/math/vector/comparison.hpp</code></strong> defines the
following comparison operators:

<ul>
	<li><code>operator==</code></li>
	<li><code>operator!=</code></li>
	<li><code>operator<=</code></li>
	<li><code>operator<</code></li>
	<li><code>operator>=</code></li>
	<li><code>operator></code></li>
</ul>

All of these work component-wise and forward to the <code>value_type</code>'s
operators. The ordering is lexicographic. This means that you can use a vector
with associative containers like <code>std::%set,std::%map,...</code>. Keep in
mind that the equality comparison operators do <em>not</em> use an epsilon so
you <em>will</em> get exact floating point comparisons (be sure that you really
want that!).

Including <strong><code>fcppt/math/vector/arithmetic.hpp</code></strong> gives
you the following operators:

<ul>
	<li><code>operator+=(vector::object<T,N,S>)</code></li>
	<li><code>operator-=(vector::object<T,N,S>)</code></li>
	<li><code>operator*=(vector::object<T,N,S>)</code></li>
	<li><code>operator/=(vector::object<T,N,S>)</code></li>
	<li><code>operator%=(vector::object<T,N,S>)</code></li>
	<li><code>operator*=(T)</code> (multiply by a scalar)</li>
	<li><code>operator/=(T)</code> (divide by a scalar)</li>
	<li><code>operator+(vector::object<T1,N,S>,vector::object<T2,N,S>)</code></li>
	<li><code>operator-(vector::object<T1,N,S>,vector::object<T2,N,S>)</code></li>
	<li><code>operator*(vector::object<T1,N,S>,vector::object<T2,N,S>)</code></li>
	<li><code>operator/(vector::object<T1,N,S>,vector::object<T2,N,S>)</code></li>
	<li><code>operator%(vector::object<T1,N,S>,vector::object<T2,N,S>)</code></li>
	<li><code>operator*(T1,vector::object<T2,N,S>)</code> (scalar multiplication)</li>
	<li><code>operator/(T1,vector::object<T2,N,S>)</code> (scalar division)</li>
	<li>Unary minus for vectors</li>
</ul>

The arithmetic operators all work component-wise. Note that
<code>operator*</code> does not denote the dot or cross product, but the
component-wise product. See \link fcppt::math::vector::dot\endlink and
\link fcppt::math::vector::cross\endlink.

It is important to note that all of the free operators support that the value
types of their arguments differ. Suppose we can divide meters by seconds to get
speed.

\snippet math/vector.cpp asymmetric_div_decl

This can now be used to divide vectors of meters by vectors of seconds to
obtain vectors of speeds.

\snippet math/vector.cpp asymmetric_div

<strong><code>fcppt/math/vector/input.hpp</code></strong> defines
<code>operator>></code> for reading input from standard streams.
Conversely, <strong><code>fcppt/math/vector/output.hpp</code></strong> defines
an inverse <code>operator<<</code>.

<strong><code>fcppt/math/vector/dim.hpp</code></strong> defines:
<ul>
	<li><code>operator+(vector::object<T1,N,S1>,dim::object<T2,N,S2>)</code></li>
	<li><code>operator-(vector::object<T1,N,S1>,dim::object<T2,N,S2>)</code></li>
	<li><code>operator*(vector::object<T1,N,S1>,dim::object<T2,N,S2>)</code></li>
	<li><code>operator/(vector::object<T1,N,S1>,dim::object<T2,N,S2>)</code></li>
	<li><code>operator%(vector::object<T1,N,S1>,dim::object<T2,N,S2>)</code></li>
</ul>

Again, these work component-wise and have support for asymmetric argument types.

\section fcpptmathvector_headers Header files

<table>
<tr>
<th>Header file</th>
<th>Description</th>
</tr>
<tr>
<td><code>object_fwd.hpp</code></td>
<td>Contains \link fcppt::math::vector::object object's \endlink declaration. Include this if you pass a vector by reference, for example.</td>
</tr>
<tr>
<td><code>object_decl.hpp</code></td>
<td>Contains \link fcppt::math::vector::object object's \endlink definition.</td>
</tr>
<tr>
<td><code>object_impl.hpp</code></td>
<td>Contains the definition of \link fcppt::math::vector::object object's \endlink member functions.</td>
</tr>
<tr>
<td><code>object.hpp</code></td>
<td>Includes <code>object_fwd.hpp</code>, <code>object_decl.hpp</code> and <code>object_impl.hpp</code></td>
</tr>
<tr>
<td><code>arithmetic.hpp</code></td>
<td>Contains \link fcppt::math::vector::object object's \endlink arithmetic operators.</td>
</tr>
<tr>
<td><code>comparison.hpp</code></td>
<td>Contains \link fcppt::math::vector::object object's \endlink comparison operators.</td>
</tr>
<tr>
<td><code>input.hpp</code></td>
<td>Contains an <code>operator>></code> for the standard input streams (wide and narrow) which expects vectors to be input in the format: <code>(v1,v2,...)</code></td>
</tr>
<tr>
<td><code>output.hpp</code></td>
<td>Contains an <code>operator<<</code> for the standard input streams (wide and narrow) which outputs vectors in the format: <code>(v1,v2,...)</code></td>
</tr>
<tr>
<td><code>dim.hpp</code></td>
<td>Contains arithmetic operators to interoperate with the \link fcppt::math::dim::object\endlink class (see this class for more information)</td>
</tr>
</table>
*/
