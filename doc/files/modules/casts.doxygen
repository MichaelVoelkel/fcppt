/**
\defgroup fcpptcasts fcppt.casts
\ingroup fcpptmain
\brief Cast helpers which provide more type information or do additional checks

<table id="toc">
<tr>
<td>

<ol>
	<li>\ref fcpptcasts_dynamic_casting</li>
	<li>\ref fcpptcasts_truncation_check_cast</li>
	<li>\ref fcpptcasts_safe_conversions</li>
</ol>

</td>
</tr>
</table>


\section fcpptcasts_dynamic_casting Dynamic casting

Let's say you have the following extremely simple class hierarchy:

\code
class base
{
	// Just to make the base class polymorphic
	virtual ~base() {}
};

class derived : public base
{
};

int main()
{
	derived most_derived;
	base &base_ref = most_derived;

	// More to come...
}
\endcode

In C++, when you have a base class and want to "get to" a derived class, you have three options:

<ol>
	<li>
	<strong><code>static_cast</code></strong>: This is the unsafest cast of
	them all. If it fails, you get undefined behaviour (meaning you
	application will crash at a random place):

	\code
	derived &d = static_cast<derived &>(base_ref);
	\endcode

	Because it does no error-checking, however, this cast will be the
	fastest. You can do it when you're sure the base class reference you
	have is really pointing to a derived class.
	</li>
	<li>
	<strong><code>dynamic_cast</code> with pointers</strong>: If you're not
	sure that the base class reference you have is really pointing to a
	derived class <code>derived</code>, you can do an error-checking test
	such as the dynamic cast with pointers:

	\code
	derived *d = dynamic_cast<derived *>(base_ref);

	if(d)
		std::cout << "Yeah, it worked!\n";
	else
		std::cout << "Ooops, wrong type\n";
	\endcode

	This is still pretty fast and it's safer. But you have to use pointers, which is pretty ugly.
	</li>
	<li>
	<strong><code>dynamic_cast</code> with references</strong>: If you
	replace the pointers in the above example by references, you get the
	third method of casting:

	\code
	derived &d = dynamic_cast<derived &>(base_ref);
	\endcode

	This is still safe. Why? Well, it'll throw an exception
	(<code>std::%bad_cast</code>) if the cast doesn't work. This, however,
	might not be what you want, for several reasons:

	For one, the exception gives you absolutely no information about what
	went wrong. But what you might want to know, for example, is which type
	failed to convert to which other type?

	Also, you cannot use this cast in an <code>if</code> statement. You
	have to use either pointers or a <code>catch</code> block to achieve
	that.
	</li>
</ol>

For these reasons, fcppt provides helpers for dynamic-casting. To work around
the ugly pointer cast, there is fcppt::optional_dynamic_cast which returns an
fcppt::optional.

To provie a little more information on the types for the reference
<code>dynamic_cast</code>, there is fcppt::dynamic_cast_ (mind the
underscore!).


\section fcpptcasts_truncation_check_cast Checking truncation

C++ defines several fundamental integral types: <code>unsigned char, signed
char, char, short, unsigned short, int, unsigned int, long and unsigned
long</code> ( and for <em>C++11</em> additionally <code>long long and unsigned
long long</code>).

Also, there are <code>std::size_t and std::ptrdiff_t</code> which can even be
different from every type mentioned above.

Sometimes, it is necessary to convert between these types, which is dangerous
if the conversion doesn't preserve the original value. This can happen if the
result (as a magnitude) doesn't fit into the destination type, or if signedness
cannot be preserved. If the destination type is signed, the result is even
implmementation-defined if the value cannot be preserved, which is especially
dangerous.

To automatically check for such conditions, fcppt provides
fcppt::truncation_check_cast.

In the following example, it is tested if the biggest <code>unsigned
long</code> value fits into an <code>unsigned int</code>. This might be true,
depending on the architecture.

\snippet truncation_check_cast.cpp truncation_check_cast_int_long

Truncating conversions of negative values are also detected.

\snippet truncation_check_cast.cpp truncation_check_cast_negative

\section fcpptcasts_safe_conversions Safe conversions

In C++, almost every fundamental type is implicitly convertible to almost every
other fundamental type. For example, all arithmetic types can be implicitly
converted into each other, which means integers to floats, floats to integers,
bigger to smaller types, etc.

The major problem with this is that most of these conversions don't preserve
values (see also \ref fcpptcasts_truncation_check_cast for problems that can
occur when converting between different integer types). Conversions from
integers to floats and vice versa almost always lose some part of the value.

fcppt::safe_numeric_cast is a cast that doesn't do any runtime checking (as
opposed to fcppt::truncation_check_cast) but it checks at compile time which
conversions between arithmetic types are safe, see fcppt::safe_numeric_cast for
a detailed description which conditions must hold true in order for the cast to
compile.

The following example shows how a class's constructor can be strengthened by
fcppt::safe_numeric_cast :

\snippet safe_numeric_cast.cpp safe_numeric_cast_class

Here are some examples of how the constructor can and can't be called:

\snippet safe_numeric_cast.cpp safe_numeric_cast_objects

fcppt::safe_cast is another cast that extends the set of types that
fcppt::safe_numeric_cast can cast. If the types are both arithmetic types, then
they will be converted using fcppt::safe_numeric_cast, otherwise they must be
implicitly convertible. This is used for constructing strong typedefs,
see
\link
fcpptstrongtypedef strong typedefs\endlink.

*/
