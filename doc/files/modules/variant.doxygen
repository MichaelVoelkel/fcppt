namespace fcppt
{
/**
\brief Contains fcppt::variant::object and helper types/functions for it
*/
namespace variant
{
}
}

/**
\defgroup fcpptvariant fcppt.variant
\ingroup fcpptmain
\brief A class that can hold any object from a fixed set of types

<table id="toc">
<tr>
<td>

<ul>
	<li>\ref variant_motivation</li>
	<li>\ref variant_visitation</li>
	<li>\ref variant_access</li>
	<li>\ref variant_design</li>
	<li>\ref variant_headers</li>
</ul>

</td>
</tr>
</table>

\section variant_motivation Motivation

A variant is a type that can hold objects of a fixed set of types, which is
sometimes also called a <em>sum type</em>. The closest language feature in C++
are unions, which are very low-level and dangerous to use:
<ul>

<li>A union does not know which type of object it actually holds. This can also
be nothing at all when the union has not been initialized.</li>

<li>Accessing the wrong type is undefined behaviour.</li>

<li>A union also does not know how to call constructors or destructors.</li>

</ul>

\snippet variant/motivation.cpp variant_union

<code>%fcppt::variant</code> fixes the aforementioned problems in the following way:

<ul>

<li>It keeps track of which type it holds.</li>

<li>It is not default-constructible.</li>

<li>It calls constructors, assignment operators and destructors as needed.</li>

<li>Safe access is provided, similar to \ref fcpptoptional.</li>

</ul>

Consider a variant of an int and a string, for which we provide a print function:

\snippet variant/motivation.cpp variant_example

Notice that we do not query which type the variant holds. Instead, we make use
of \link fcppt::variant::match\endlink and write out all cases explicitly.

\section variant_visitation Visitation

A more general way to access variants is called <em>visitation</em>, which is
similar to <em>pattern matching</em>. A visitor is a struct or class that uses
an <em>overloaded</em> <code>operator()</code> to distinguish between the
possible types of a variant.

Suppose we want to define a visitor that does something different for all
<em>integral types</em>. The easiest way this can be done is by using
<code>std::enable_if</code>.

\snippet variant/visitation.cpp variant_visitor

The following code shows how such a visitor is called:

\snippet variant/visitation.cpp variant_visitor_apply

\link fcppt::variant::apply_binary \endlink and \link
fcppt::variant::apply_ternary \endlink are also provided. These can be used to
visit two or three variants at the same time. In this case, the
<code>operator()</code> takes two or three arguments, respectively.

Here is a small example for defining a binary visitor:

\snippet variant/binary_visitation.cpp variant_binary_visitation

Non-const visitation, which means that the visited variant can be modified, is
also supported.

\snippet variant/nonconst_visitation.cpp variant_nonconst_visitor
\snippet variant/nonconst_visitation.cpp variant_nonconst_visitation

\section variant_access Access

Visitation and matching are the most common ways to access a variant. The
other ways are:
<ul>
<li>\link fcppt::variant::get_exn\endlink which throws an exception
if the variant does not hold the queried type.</li>
<li>\link fcppt::variant::get_unsafe\endlink which does not check if the
variant actually holds the queried type. It is comparable to
<code>static_cast</code> to a derived class.</li>
<li>\link fcppt::variant::to_optional\endlink returns an optional to
the queried type. Similarly, \link fcppt::variant::to_optional_ref\endlink returns
an optional reference.</li>
</ul>

\section variant_design Design

While the design of <code>fcppt::variant</code> is similar to
<code>%boost::variant</code>, there are some key differences:

<ul>

<li><code>%fcppt::variant</code> does not provide a default constructor.
<code>%boost::variant</code> default constructs the first type of all possible
types instead, which does not make any sense.</li>

<li><code>%fcppt::variant</code>'s constructor is explicit.</li>

<li><code>%fcppt::variant</code> does not allow any implicit conversions in its
constructors.</li>

<li><code>%fcppt::variant</code> allows non const visitation and visitation of
rvalues. <code>%boost::variant</code> only supports visitation of
lvalues.</li>

<li><code>%fcppt::variant</code> provides ternary visitation.</li>

<li><code>%fcppt::variant</code> reuses MPL instead of generating the template
over and over for every number of possible types. It is therefore as extensible
as MPL is.</li>

<li><code>%boost::variant</code> offers the so-called "non-empty" guarantee.
This means that a variant always holds one of its possible types, which is
generally a good thing. However, the difficult part about this guarantee is
that an assignment of an object of different type than the variant already
holds can throw an exception. In more detail, this means that the variant first
has to destroy the object that is being held to make the store available for
the new object. Then, if copy construction of the new object fails, there is no
way to recover from that. <code>%boost::variant</code> circumvents that by
heap-allocating the new object which can then safely be moved after destroying
the old object. <code>%fcppt::variant</code> instead allows this corner case to
leave the variant in an unspecified state which can only be used to destroy the
variant or to assign a new object.</li>

<li><code>%fcppt::variant</code> uses alignment support from the compiler
instead of relying on <code>%boost::detail::aligned_storage</code>.</li>

</ul>

\section variant_headers Header files
<table>
<tr>
<th>Header file</th>
<th>Description</th>
</tr>
<tr>
<td><code>object_fwd.hpp</code></td>
<td>Contains \link fcppt::variant::object variants's \endlink declaration.</td>
</tr>
<tr>
<td><code>object_decl.hpp</code></td>
<td>Contains \link fcppt::variant::object variant's \endlink definition.</td>
</tr>
<tr>
<td><code>object_impl.hpp</code></td>
<td>Contains the definition of \link fcppt::variant::object variants's \endlink member functions.</td>
</tr>
<tr>
<td><code>object.hpp</code></td>
<td>The same as <code>object_impl.hpp</code>.</td>
</tr>
<tr>
<td><code>apply_unary.hpp</code></td>
<td>Contains \link fcppt::variant::apply_unary \endlink for unary visitation.</td>
</tr>
<tr>
<td><code>apply_binary.hpp</code></td>
<td>Contains \link fcppt::variant::apply_binary \endlink for binary visitation.</td>
</tr>
<tr>
<td><code>apply_ternary.hpp</code></td>
<td>Contains \link fcppt::variant::apply_ternary \endlink for ternary visitation.</td>
</tr>
<tr>
<td><code>compare.hpp</code></td>
<td>Contains \link fcppt::variant::compare \endlink.</td>
</tr>
<tr>
<td><code>comparison.hpp</code></td>
<td>Includes <code>equal.hpp</code> and <code>not_equal.hpp</code>.</td>
</tr>
<tr>
<td><code>equal.hpp</code></td>
<td>Contains <code>operator==</code>.</td>
</tr>
<tr>
<td><code>exception.hpp</code></td>
<td>Contains \link fcppt::variant::exception \endlink, the base class for every
variant exception.</td>
</tr>
<tr>
<td><code>get_exn.hpp</code></td>
<td>Contains \link fcppt::variant::get_exn \endlink.</td>
</tr>
<tr>
<td><code>get_unsafe.hpp</code></td>
<td>Contains \link fcppt::variant::get_unsafe \endlink which does the same
thing as the \link fcppt::variant::object::get_unsafe\endlink member
function.</td>
</tr>
<tr>
<td><code>holds_type.hpp</code></td>
<td>Contains the \link fcppt::variant::holds_type \endlink function to check if
a type is held by the variant.</td>
</tr>
<tr>
<td><code>invalid_get.hpp</code></td>
<td>Contains \link fcppt::variant::invalid_get \endlink, which might be thrown
by \link fcppt::variant::get_exn \endlink.</td>
</tr>
<tr>
<td><code>less.hpp</code></td>
<td>Contains <code>operator<</code>.</td>
</tr>
<tr>
<td><code>match.hpp</code></td>
<td>Contains \link fcppt::variant::match\endlink.</td>
</tr>
<tr>
<td><code>not_equal.hpp</code></td>
<td>Contains <code>operator!=</code>.</td>
</tr>
<tr>
<td><code>output.hpp</code></td>
<td>Contains <code>operator<<</code> for output.</td>
</tr>
<tr>
<td><code>to_optional.hpp</code></td>
<td>Contains \link fcppt::variant::to_optional\endlink.</td>
</tr>
<tr>
<td><code>to_optional_ref.hpp</code></td>
<td>Contains \link fcppt::variant::to_optional_ref\endlink.</td>
</tr>
<tr>
<td><code>type_info.hpp</code></td>
<td>Contains \link fcppt::variant::type_info\endlink.</td>
</tr>
<tr>
<td><code>variadic_fwd.hpp</code></td>
<td>Contains \link fcppt::variant::variadic\endlink and declares \link fcppt::variant::object\endlink.</td>
</tr>
<tr>
<td><code>variadic.hpp</code></td>
<td>Includes <code>fcppt/variant/object_fwd.hpp</code> and defines \link fcppt::variant::object\endlink.</td>
</tr>
</table>
*/
