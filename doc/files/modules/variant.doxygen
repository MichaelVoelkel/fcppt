namespace fcppt
{
/**
\brief Contains fcppt::variant::object and helper types/functions for it
*/
namespace variant
{
}
}

/**
\defgroup fcpptvariant fcppt.variant
\ingroup fcpptmain
\brief A class that can hold any object from a fixed set of types

<table id="toc">
<tr>
<td>

<ul>
	<li>\ref variant_motivation</li>
	<li>\ref variant_visitation</li>
	<li>\ref variant_design</li>
	<li>\ref variant_headers</li>
</ul>

</td>
</tr>
</table>

\section variant_motivation Motivation

It might be necessary to store objects of different types in a variable.
C++ has so called unions which can do that. However, a union has several
disadvantages:
<ul>

<li>It doesn't know which type of object it actually holds. This can also be
nothing at all when the union has not been initialized.</li>

<li>If you access the wrong type of the union, then the behaviour is
undefined.</li>

<li>A union also doesn't know how to call constructors or destructors (this has
been relaxed in C++11 but it is still cumbersome). So you are very restricted
with the types of objects you can store in them.</li>

</ul>

\snippet variant/motivation.cpp variant_union

In order to fix the aforementioned problems, fcppt::variant's approach is very
different to a union.

<ul>

<li>It knows which type it holds.</li>

<li>It is not default constructible which doesn't make any sense for
variants.</li>

<li>It calls constructors, assignment operators and destructors as needed.</li>

<li>Safe operations on variants are provided which make it impossible to access
the wrong type.</li>

</ul>

The above example can be rewritten as follows:

\snippet variant/motivation.cpp variant_example

While this removes a lot of the problems unions have, we still have to access
the variant's elements explicitly which can lead to undefined behavior if we
get it wrong.

\section variant_visitation Visitation

Not only is the previous unsafe, it is also tedious.

In order to solve this, there is a mechanism called visitation. A class that
can visit a set of types is called a visitor. Instead of focusing on making the
set of types extensible, visitation aims to make the set of operations on them
extensible. The downside of this is that the visitor has to know about all
types in the set. Luckily, that's better than it sounds. A visitor can employ
all sorts of C++ template mechanisms to make this easier.

To define a visitor, it must have function call operators so that for all types
in the set exactly one of them matches. The function call operators must also
be <code>const</code>. The visitor must have a typedef <code>result_type</code>
which must be the result type of every function call operator it provides.

\snippet variant/visitation.cpp variant_visit_simple

In this case, it is possible to employ templates to make the visitor a lot
easier.

\snippet variant/visitation.cpp variant_visit_template

It is often advisable to make a visitor as generic as possible. enable_if
combined with type traits can also help.

\link fcppt::variant::apply_binary \endlink and \link
fcppt::variant::apply_ternary \endlink are also provided. These can be used to
visit two or three variants at the same time.  In this case, the operator()
takes two or three arguments, respectively.

Here is a small example for defining a binary visitor:

\snippet variant/binary_visitation.cpp variant_binary_visitor
\snippet variant/binary_visitation.cpp variant_binary_visitation

Non const visitation, which means that the visited variant can be modified, is
also supported, thanks to C++11's perfect forwarding.

\snippet variant/nonconst_visitation.cpp variant_nonconst_visitor
\snippet variant/nonconst_visitation.cpp variant_nonconst_visitation

\section variant_design Design

There is already <code>%boost::variant</code> so you might wonder why fcppt
provides its own variant type.

The key differences to <code>%boost::variant</code> are
<ul>

<li>fcppt::variant::object uses alignment support from the compiler instead of
relying on the hacky <code>%boost::detail::aligned_storage</code></li>

<li>fcppt::variant::object doesn't provide a default constructor.
<code>%boost::variant</code> default contructs the first type of all possible
types instead, which doesn't make any sense.</li>

<li>fcppt::variant has properly separated headers and resides in its own
namespace.</li>

<li>fcppt::variant provides ternary visitation</li>

<li>fcppt::variant reuses MPL instead of generating the template over and over
for every number of possible types. It is therefore as extensible as MPL
is.</li>

<li>fcppt::variant::object doesn't allow any implicit conversions for possible
types. You should explicitly convert instead.</li>

<li>fcppt::variant allows non const visitation and visitation of rvalues,
thanks to C++11. <code>%boost::variant</code> only supports visitation of
lvalues.</li>

<li><code>%boost::variant</code> offers the so-called "non-empty" guarantee.
This means that a variant always holds one of its possible types, which is
generally a good thing. However, the difficult part about this guarantee is
that an assignment of an object of different type than the variant already
holds can throw an exception. In more detail, this means that the variant first
has to destroy the object that is being held to make the store available for
the new object. Then, if copy construction of the new object fails, there is no
way to recover from that. <code>%boost::variant</code> circumvents that by
heap-allocating the new object which can then safely be moved after destroying
the old object. fcppt::variant instead allows this corner case to leave the
variant in an unspecified state which can only be used to destroy the variant
or to assign a new object.</li>

</ul>

\section variant_headers Header files
<table>
<tr>
<th>Header file</th>
<th>Description</th>
</tr>
<tr>
<td><code>object_fwd.hpp</code></td>
<td>Contains \link fcppt::variant::object variants's \endlink declaration.</td>
</tr>
<tr>
<td><code>object_decl.hpp</code></td>
<td>Contains \link fcppt::variant::object variant's \endlink definition.</td>
</tr>
<tr>
<td><code>object_impl.hpp</code></td>
<td>Contains the definition of \link fcppt::variant::object variants's \endlink member functions.</td>
</tr>
<tr>
<td><code>apply_unary.hpp</code></td>
<td>Contains \link fcppt::variant::apply_unary \endlink for unary visitation.</td>
</tr>
<tr>
<td><code>apply_binary.hpp</code></td>
<td>Contains \link fcppt::variant::apply_binary \endlink for binary visitation.</td>
</tr>
<tr>
<td><code>apply_ternary.hpp</code></td>
<td>Contains \link fcppt::variant::apply_ternary \endlink for ternary visitation.</td>
</tr>
<tr>
<td><code>equal.hpp</code></td>
<td>Contains operator==</td>
</tr>
<tr>
<td><code>exception.hpp</code></td>
<td>Contains \link fcppt::variant::exception \endlink, the base class for every
variant exception.</td>
</tr>
<tr>
<td><code>get_exn.hpp</code></td>
<td>Contains a free \link fcppt::variant::get_exn \endlink function which does
the same thing as the get_exn member function.</td>
</tr>
<tr>
<td><code>holds_type.hpp</code></td>
<td>Contains the \link fcppt::variant::holds_type \endlink function to check if
a type is held by the variant.</td>
</tr>
<tr>
<td><code>invalid_get.hpp</code></td>
<td>Contains \link fcppt::variant::invalid_get \endlink, which might be thrown
by \link fcppt::variant::get_exn \endlink</td>
</tr>
<tr>
<td><code>not_equal.hpp</code></td>
<td>Contains operator!=</td>
</tr>
<tr>
<td><code>output.hpp</code></td>
<td>Contains operator<< for output</td>
</tr>
<tr>
<td><code>to_optional.hpp</code></td>
<td>Contains \link fcppt::variant::to_optional \endlink.</td>
</tr>
</table>
*/
