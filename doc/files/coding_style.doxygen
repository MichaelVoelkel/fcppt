/**
\page code_style Coding style

<table id="toc">
<tr>
<td>

<ul>
	<li>\ref coding_introduction
	<li>\ref coding_semantics</li>
		<ul>
			<li>\ref coding_typing</li>
			<li>\ref coding_total</li>
			<li>\ref coding_loops</li>
			<li>\ref coding_const_init</li>
		</ul>
	<li>\ref coding_asthetic</li>
		<ul>
			<li>\ref coding_indentation</li>
			<li>\ref coding_naming</li>
			<li>\ref coding_partitioning</li>
		</ul>
</ul>

</td>
</tr>
</table>

\section coding_introduction Introduction

The notion of coding style used in the following section roughly consists of
two different aspects:
<ul>
<li>\link coding_asthetic Asthetic aspects\endlink, including how code is
indented, partitioned into files, identifiers are named, and so on.</li>
<li>How semantics are expressed, including typing, usage of language constructs
like loops, <code>const</code>, ownership, and so on.</li>
</ul>
In general, coding styles are somewhat arbitrary which is why this document
tries to give a rationale for every one of them.

\section coding_semantics Semantic aspects

Besides asthetic aspects, semantic aspects describe \em how semantics are
expressed. The most important goal is to avoid mistakes, or more precisely, how
choosing types and expressions carefully can narrow down the set of mistakes
one can make. Improved typing, total functions, ranges, avoiding raw loops and
making variables const all tie together in this respect.

\subsection coding_typing Typing

A (mostly) statically typed language like C++ has the advantage to forbid
programs to even run if they are not well typed. Making the most out of the type
system can catch a lot of mistakes at compile-time. We can use types to
<ul>
<li>Express ownership: Choose between <code>fcppt::unique_ptr<T></code>, <code>
fcppt::shared_ptr<T></code>, <code>fcppt::reference_wrapper<T (const)></code>,
<code>T &&</code> and <code>T</code>.
<ul>
<li>\link fcppt::unique_ptr\endlink expresses unique ownership and should be
the default class to use for non-copyable objects.</li>
<li>\link fcppt::shared_ptr\endlink expresses shared ownership.</li>
<li>\link fcppt::reference_wrapper\endlink should be prefered to raw references
to make their use more explicit.</li>
</ul>
<li>Express optional values: Can a function take or, more importantly, return
no value? Use <code>fcppt::optional<T></code> in this case. Instead of <code>T
(const) *</code>, use <code>fcppt::optional<T (const) &></code>. See \ref
fcpptoptional.</li>
<li>Express values that can be of either type: Use
<code>%fcppt::variant::variadic<T1,T2></code> to express that
a value can either be of type <code>T1</code> or of type <code>T2</code>.
See \ref fcpptvariant.</li>
<li>Wrap types as <em>strong typedefs</em>, e.g.
<code>%FCPPT_MAKE_STRONG_TYPEDEF(std::string,email_address)</code> to make their
use clearer. See \ref fcpptstrongtypedef.</li>
</ul>

\subsection coding_total Total functions

A total function is a function that is well-defined for every possible
combination of parameters. A partial function on the other hand can be
undefined for some. This includes everything that is not expressed by the type
system: undefined behavior, aborting the program or even throwing an exception.
An example of a partial function is dereferencing a pointer. The pointer might
be a null pointer, it might be uninitialized or it might point to 'one past the
end'. Calling partial functions is error-prone because the programmer always
has to remember each case where the function might not return. Consequently,
partial functions are best avoided but cannot always be:
<ul>
<li>Prefer to use \ref fcpptoptional as a return type in case a
function may not return anything, for example \link
fcppt::container::maybe_back\endlink. This usually makes a function total.</li>
<li>Throw exceptions in case resource allocation fails.</li>
<li>Only abort the program or leave a case as undefined behavior as a last
resort.</li>
</ul>
See \ref fcpptassert on how to systematically handle partial
functions.

\subsection coding_loops Loops

Loops are inherently imperative: On the one hand a loop uses and updates one or
more loop conditions. On the other hand it updates one or more variables that
are the loop's result. This is usually better expressed as a function: Instead
of a loop condition, we can usually use ranges. The simplest form of a range is
a container, but other ranges like \link fcppt::int_range\endlink or \link
fcppt::enum_range\endlink are also common. Unlike iterators, ranges have the
great advantage of being composable, for example two ranges can be joined
(taking their product) or appended, which is implemented by the
<a href="http://www.boost.org/doc/libs/1_59_0/libs/range/doc/html/index.html">Boost.Range</a>
library.

How the loop's result is formed out of a range can then be expressed by another
function. The most basic form of this is \link fcppt::algorithm::fold\endlink.
Because imperative loops, especially ones using iterators, are so error-prone,
raw loops are best avoided. See \ref fcpptalgorithm for a collection of
functions that work on ranges.

\subsection coding_const_init Const and initialization

Making an object <code>const</code> makes it immutable and therefore possible
to reason about values. Obviously, a const object has to be initialized
directly. Initialization can sometimes be hard to express, for example an array
of arbitrary size, which is handled by \link
fcppt::algorithm::array_fold_static\endlink, or a container, which is handled
by \link fcppt::algorithm::map\endlink.

Initialization also brings up the point of default constructors. A default
constructor is like pulling a value out of thin air and most of the time has
undesired effects like creating a null pointer or a null function. This is also
the reason why \link fcppt::unique_ptr\endlink and \link
fcppt::function\endlink exist. Default constructors are error-prone and best
avoided.
*/
