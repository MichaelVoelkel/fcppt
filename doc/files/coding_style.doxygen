/**
\page code_style Coding style

<table id="toc">
<tr>
<td>

<ul>
	<li>\ref coding_introduction
	<li>\ref coding_asthetic</li>
		<ul>
			<li>\ref coding_indentation</li>
			<li>\ref coding_naming</li>
			<li>\ref coding_partitioning</li>
		</ul>
	<li>\ref coding_semantics</li>
		<ul>
			<li>\ref coding_typing</li>
			<li>\ref coding_total</li>
			<li>\ref coding_loops</li>
			<li>\ref coding_const_init</li>
		</ul>
</ul>

</td>
</tr>
</table>

\section coding_introduction Introduction

The notion of coding style used in the following section roughly consists of
two different aspects:
<ul>
<li>Asthetic aspects, including how code is indented, partitioned into
files, identifiers are named, and so on.</li>
<li>How semantics are expressed, including typing, usage of language constructs
like loops, <code>const</code>, ownership, and so on.</li>
</ul>
In general, coding styles are somewhat arbitrary which is why this document
tries to give a rationale for every one of them.

\section coding_asthetic Asthetic aspects

To start off, this document gives an overview over the asthetic aspects chosen
in fcppt. Asthetic aspects are purely cosmetic and their only purpose is to
yield code that is consistent and therefore easier to understand.

\subsection coding_indentation Indentation

Indentation is a very controversal topic. Everyone has their own opinions on it
and these are also subject to change over time. Fcppt uses a somewhat excessive
indentation style whose purpose is not to be <em>identifier-dependant</em> and
<em>tab-consistent</em>. The former means that changing identifiers should not
lead to reindentation. Consider a rule that enforces lines that are no longer
than, say, 80 characters. If you change a single identifier, it could lead to
reindentation of a lot of lines. The latter means that tab width should not
affect the indentation, therefore making it possible to use tabs, so that
everyone can chose their favorite tab width.

The coding style can best be given by a simple example:
\code
result_type
my_function(
	T1 _arg1,
	T2 _arg2
)
{
	return
		expression1(
			expression2(
				_arg1
			),
			_arg2
		);
}
\endcode

\subsection coding_naming Naming

Fcppt uses C++-style naming conventions which include:
<ul>
<li>Lowercase identifiers, including underscore, for example
<code>fcppt::optional_bind</code></li>.
<li>Uppercase identifiers for macros, for example
<code>FCPPT_NONCOPYABLE</code>.</li>
</ul>

Members are named with a trailing underscore, while parameters are
named with a leading underscore:
\code
struct test
{
	explicit
	test(
		int const _arg
	)
	:
		value_(
			_arg
		)
	{
	}

	int value_;
};

test
make_test(
	int const _arg
)
{
	return
		test(
			_arg
		);
}
\endcode

\subsection coding_partitioning Partitioning

There are multiple layers of code organization in C++:
<ul>
<li>Files, which include header files and implementation (cpp) files.</li>
<li>Namespaces and prefixes for identifiers not in a namespace, like
macros.</li>
</ul>
In fcppt, both aspects are made consistent: Every identifier in a namespace
has a corresponding header path, likewise for macros and prefixes, for example:
<code>fcppt::container::maybe_front</code> resides in
<code>fcppt/container/maybe_front.hpp</code> and
<code>FCPPT_CONFIG_EXTERNAL_BEGIN</code> resides in
<code>fcppt/config/external_begin.hpp</code>.

Because C++'s declarations and linkage are so complicated, there are several
rules for where to declare and define different entities:
<ul>
<li>A function has a header and an implementation file, for example:
<code>fcppt::widen</code> has its declaration in <code>fcppt/widen.hpp</code>
and its implementation in <code>widen.cpp</code>.</li>
<li>A class has a header for its declaration, a header for its definition and
an implementation file for the definition of its functions, for example:
<code>fcppt::log::object</code> has its declaration in
<code>fcppt/log/object_fwd.hpp</code>, its definition in
<code>fcppt/log/object.hpp</code> and the implementation of its functions in
<code>log/object.cpp</code>. </li>
<li>A macro has just a single header, for example
<code>FCPPT_NONCOPYABLE</code> is defined in
<code>fcppt/noncopyable.hpp</code></li>
<li>An inline or template function only has a single header, for example
<code>fcppt::container::maybe_front</code> resides in
<code>fcppt/container/maybe_front.hpp</code>.</li>
<li>A template class, like a normal class, is also partitioned into three
files. However, all of them must be headers. For example,
<code>fcppt::math::vector::object</code> has its declaration in
<code>fcppt/math/vector/object_fwd.hpp</code>, its definition in
<code>fcppt/math/vector/object_decl.hpp</code> and the implementation of its
functions in <code>fcppt/math/vector/object_impl.hpp</code>.</li>
<li>Typedefs can have a forward declaration but are not required to. For
example, <code>fcppt::math::vector::static_</code> has its declaration in
<code>fcppt/math/vector/static_fwd.hpp</code> and the header
<code>fcppt/math/vector/static.hpp</code> includes
<code>fcppt/math/vector/object_impl.hpp</code>, leaving out the step of
including <code>fcppt/math/vector/object_decl.hpp</code>.</li>
</ul>

Partitioning code into multiple headers also brings up the question of where to
include which header. Fcppt follows a rule of <em>minimal includes</em> which
means that including declarations should be preferred over including
definitions. For example, when a function <code>T f(U)</code> is declared, it
is enough to include the declarations of <code>T</code> and <code>U</code>
only.

\section coding_semantics Semantic aspects

Besides asthetic aspects, semantic aspects describe \em how semantics are
expressed. The most important goal is to avoid mistakes, or more precisely, how
choosing types and expressions carefully can narrow down the set of mistakes
one can make. Improved typing, total functions, ranges, avoiding raw loops and
making variables const all tie together in this respect.

\subsection coding_typing Typing

A (mostly) statically typed language like C++ has the advantage to forbid
programs to even run that are not well typed. Making the most out of the type
system can catch a lot of mistakes at compile-time. We can use types to
<ul>
<li>Express ownership: Choose between <code>fcppt::unique_ptr<T></code>, <code>
fcppt::shared_ptr<T></code>, <code>fcppt::reference_wrapper<T (const)></code>,
<code>T &&</code> and <code>T</code>.</li>
<li>Express optional values: Can a function take or, more importantly, return
no value? Use <code>fcppt::optional<T></code> in this case. Instead of <code>T
(const) *</code>, use <code>fcppt::optional<T (const) &></code>.</li>
<li>Express values that can be of either type: Use
<code>fcppt::variant::object<boost::mpl::vector<T1,T2>></code> to express that
a value can either be of type <code>T1</code> or of type <code>T2</code>.</li>
<li>Wrap types as <em>strong typedefs</em>, e.g.
<code>FCPPT_MAKE_STRONG_TYPEDEF(std::string,email_address)</code> to make their
use clearer.</li>
</ul>

\subsection coding_total Total functions

A total function is a function that is well-defined for every possible
combination of parameters. A partial function on the other hand can be
undefined for some. This includes everything that is not expressed by the type
system: undefined behavior, aborting the program or even throwing an exception.
An example of a partial function is dereferencing a pointer. The pointer might
be a null pointer, it might be uninitialized or it might point to 'one past the
end'. Calling partial functions is error-prone because the programmer always
has to remember each case where the function might not return. Consequently,
partial functions are best avoided but cannot always be:
<ul>
<li>Prefer to use <code>fcppt::optional</code> as a return type in case a
function may not return anything, for example \link
fcppt::container::maybe_back\endlink. This usually makes a function total.</li>
<li>Throw exceptions in case resource allocation fails.</li>
<li>Only abort the program or leave a case as undefined behavior as a last
resort.</li>
</ul>

\subsection coding_loops Loops

Loops are inherently imperative: On the one hand a loop uses and updates one or
more loop conditions and one or more variables that are the loop's result.
This is usually better expressed as a function: Instead of a loop condition, we
can usually use ranges. The simplest form a range is a container, but other
ranges like \link fcppt::int_range\endlink are also common. Unlinke iterators,
ranges have the great advantage of being composable, for example two ranges can
be joined (taking their product) or appended. How the loop's result is formed
out of a range can then be expressed by another function. The most basic form
of this is \link fcppt::algorithm::fold\endlink. Because imperative loops,
especially ones using iterators, are so error-prone, raw loops are best
avoided.

\subsection coding_const_init Const and initialization

Making an object <code>const</code> makes it immutable and therefore possible
to reason about values. Obviously, a const object has to be initialized
directly. Initialization can sometimes be hard to express, for example an array
of arbitrary size, which is handled by \link
fcppt::algorithm::array_fold_static\endlink, or a container, which is handled
by \link fcppt::algorithm::map\endlink.

Initialization also brings up the point of default constructors. A default
constructor is like pulling a value out of thin air and most of the time has
undesired effects like creating a null pointer or a null function. This is also
the reason why \link fcppt::unique_ptr\endlink and \link
fcppt::function\endlink exist. Default constructors are error-prone and best
avoided.
*/
