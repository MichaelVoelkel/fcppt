/**
\page code_style Coding style

<table id="toc">
<tr>
<td>

<ul>
	<li>\ref coding_introduction
	<li>\ref coding_asthetic</li>
		<ul>
			<li>\ref coding_indentation</li>
			<li>\ref coding_naming</li>
			<li>\ref coding_partitioning</li>
			<li>\ref coding_includes</li>
		</ul>
	<li>\ref coding_semantics</li>
</ul>

</td>
</tr>
</table>

\section coding_introduction Introduction

The notion of coding style used in the following section roughly consists of
two different aspects:
<ul>
<li>Asthetic aspects, including how code is indented, partitioned into
files, identifiers are named, and so on.</li>
<li>How semantics are expressed, including typing, usage of language constructs
like loops, <code>const</code>, ownership, and so on.</li>
</ul>
In general, coding styles are somewhat arbitrary which is why this document
tries to give a rationale for every one of them.

\section coding_asthetic Asthetic aspects

To start off, this document gives an overview over the asthetic aspects chosen
in fcppt. Asthetic aspects are purely cosmetic and their only purpose is to
yield code that is consistent and therefore easier to understand.

\subsection coding_indentation Indentation

Indentation is a very controversal topic. Everyone has their own opinions on it
and these are also subject to change over time. Fcppt uses a somewhat excessive
indentation style whose purpose is not to be <em>identifier-dependant</em> and
<em>tab-consistent</em>. The former means that changing identifiers should not
lead to reindentation. Consider a rule that enforces lines that are no longer
than, say, 80 characters. If you change a single identifier, it could lead to
reindentation of a lot of lines. The latter means that tab width should not
affect the indentation, therefore making it possible to use tabs, so that
everyone can chose their favorite tab width.

The coding style can best be given by a simple example:
\code
result_type
my_function(
	T1 _arg1,
	T2 _arg2
)
{
	return
		expression1(
			expression2(
				_arg1
			),
			_arg2
		);
}
\endcode

\subsection coding_naming Naming

Fcppt uses C++-style naming conventions which include:
<ul>
<li>Lowercase identifiers, including underscore, for example
<code>fcppt::optional_bind</code></li>.
<li>Uppercase identifiers for macros, for example
<code>FCPPT_NONCOPYABLE</code>.</li>
</ul>

Members are named with a trailing underscore, while parameters are
named with a leading underscore:
\code
struct test
{
	explicit
	test(
		int const _arg
	)
	:
		value_(
			_arg
		)
	{
	}

	int value_;
};

test
make_test(
	int const _arg
)
{
	return
		test(
			_arg
		);
}
\endcode

\subsection coding_partitioning Partitioning

There are multiple layers of code organization in C++:
<ul>
<li>Files, which include header files and implementation (cpp) files.</li>
<li>Namespaces and prefixes for identifiers not in a namespace, like
macros.</li>
</ul>
In fcppt, both aspects are made consistent: Every identifier in a namespace
has a corresponding header path, likewise for macros and prefixes, for example:
<code>fcppt::container::maybe_front</code> resides in
<code>fcppt/container/maybe_front.hpp</code> and
<code>FCPPT_CONFIG_EXTERNAL_BEGIN</code> resides in
<code>fcppt/config/external_begin.hpp</code>.

Because C++'s declarations and linkage are so complicated, there are several
rules for where to declare and define different entities:
<ul>
<li>A function has a header and an implementation file, for example:
<code>fcppt::widen</code> has its declaration in <code>fcppt/widen.hpp</code>
and its implementation in <code>widen.cpp</code>.</li>
<li>A class has a header for its declaration, a header for its definition and
an implementation file for the definition of its functions, for example:
<code>fcppt::log::object</code> has its declaration in
<code>fcppt/log/object_fwd.hpp</code>, its definition in
<code>fcppt/log/object.hpp</code> and the implementation of its functions in
<code>log/object.cpp</code>. </li>
<li>A macro has just a single header, for example
<code>FCPPT_NONCOPYABLE</code> is defined in
<code>fcppt/noncopyable.hpp</code></li>
<li>An inline or template function only has a single header, for example
<code>fcppt::container::maybe_front</code> resides in
<code>fcppt/container/maybe_front.hpp</code>.</li>
<li>A template class, like a normal class, is also partitioned into three
files. However, all of them must be headers. For example,
<code>fcppt::math::vector::object</code> has its declaration in
<code>fcppt/math/vector/object_fwd.hpp</code>, its definition in
<code>fcppt/math/vector/object_decl.hpp</code> and the implementation of its
functions in <code>fcppt/math/vector/object_impl.hpp</code>.</li>
<li>Typedefs can have a forward declaration but are not required to. For
example, <code>fcppt::math::vector::static_</code> has its declaration in
<code>fcppt/math/vector/static_fwd.hpp</code> and the header
<code>fcppt/math/vector/static.hpp</code> includes
<code>fcppt/math/vector/object_impl.hpp</code>, leaving out the step of
including <code>fcppt/math/vector/object_decl.hpp</code>.</li>
</ul>

\subsection coding_includes Minimal includes

\section coding_semantics Semantic aspects
*/
