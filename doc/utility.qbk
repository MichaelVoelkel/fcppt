[section Utility]

[section safe_bool]

Often you might want to add `operator !` to a class to test if it is not set.
Examples are boost::shared_ptr, std::auto_ptr and so on. But you may also want
to test the opposite and using `!!` for that isn't too appealing.

[import ../examples/safe_bool.cpp]

[safebool_usage]

So how can this be done? The problem is that there is no operator that can
be overloaded directly to provide this kind of behaviour. But it is possible
to specify conversion operators that are considered when the expression should
be converted to bool.
`operator bool` could be used, but then the class can be converted into almost
anything that can be converted from a bool, so we don't want that.
fcppt implements a macro to safely implement the "bool conversion idiom".
The class has to use the macro FCPPT_SAFE_BOOL and implement `bool boolean_test() const`.

[safebool_example]

[endsect]

[section Assertions]

[section Description]

The C standard library macro `assert` (defined in `<cassert>`) doesn't throw an exception if the given condition isn't satisfied. Instead, `abort()` is called and all destructors are ignored. This can leave the system in a suboptimal state. Imagine a full screen renderer which doesn't change the videomode after a crash, leaving you with garbled video output.

To remedy this situation, there are `FCPPT_ASSERT` and `FCPPT_ASSERT_MESSAGE`. These macros will throw `fcppt::assertion_failed` instead of aborting the program abruply. Here's a small example:

[import ../examples/assert.cpp]
[assert]

Note that the asserts are still macros, because they use the `__LINE__` and `__FILE__` constants internally.

Note also that it is currently impossible to deactivate assertions via a preprocessor directive and it is disputed if that will ever be possible.

[endsect]

[xinclude doxygen_assert.xml]

[endsect]

[section Assign]

[section Description]

This part of fcppt is similar to boost::assign, but fixes one issue: Why is there `list_of`, which has a Method `to_adapter`? Why not just a single templated `make_container` function? This is exactly what `fcppt::assign` consists of. It even works for associative containers (like `std::map` or `std::set`). It uses `fcppt::container::is_associative` to determine if a container is really an associative container and if so, uses `insert` instead of `push_back`. Here is an example:

[import ../examples/make_container.cpp]
[make_container]

There's also `assign::make_array` which can be used to construct an `std::tr1::array`, whose size is determined by the how many elements you call `make_array` with. Here's an example which should explain everything:

[import ../examples/make_array.cpp]
[make_array]

[endsect]

[xinclude doxygen_assign.xml]

[endsect]

[section endianness]
fcppt has functions to deal with endianness. Here is an example:

[import ../examples/endianness.cpp]
[endianness]

[xinclude doxygen_endianness.xml]
[endsect]

[section for_each_enumerator]

Sometimes it is desired to do a loop over each enumerator of an enum.
The ugly part is that you have to use an integral type
and cast it back to an enumerator in each iteration.
`FCPPT_FOREACH_ENUMERATOR` does just that but wraps the the loop inside a macro.

[import ../examples/foreach_enumerator.cpp]

[foreach_enumerator]

[endsect]

[section strong_typedef]

A normal typedef is just a synonym.
It is impossible to overload on typedef names nor is it possible to force their use.

``
  typedef int type1;
  typedef int type2;

  void f(type1);
  void f(type2); // doesn't work!

  void g(type1);

  void h()
  {
    g(42); // no mention of type1
  }
``

A strong typedef is a kind of typedef that imposes restrictions on the typedeffed type.
You can't implicitly convert the wrapped type into the typedeffed type.
This way strong typedefs can make function calls more explicit, provide
overloading on "the same" types or generally catch programming errors.

Because a template meta function is a real mathematical function (which means it is right-unique),
there is no way to create a new type just by using templates.
A new type has to be created instead (which can be done by defining a new class, struct, enum or union).
`fcppt::strong_typedef` is therefore a type that gets two template parameters:

* The wrapped type
* A unique type (just for typedef purposes)

[import ../examples/strongtypedef.cpp]

[strongtypedef_simple]

There is also a macro to ease the process of creating distinct types.

[strongtypedef_macro]

[endsect]

[endsect]
