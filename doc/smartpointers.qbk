[section Smart Pointers]

[section Introduction]

Smart pointers are wrappers around pointers that handle ownership.
They are well known in C++. Boost already provides a set of smart pointer
classes like `boost::shared_ptr`, `boost::weak_ptr` and `boost::scoped_ptr`.
fcppt does so as well.

[endsect]

[section shared_ptr]

`fcppt::shared_ptr` is a wrapper around
`boost::shared_ptr` that takes its deleter as a template template parameter.
This can save you some typing and is less error prone than passing the
deleter in every constructor call. It also has drawbacks because the deleter
has to be known at compile time.

[section Example]

Here is an example of a factory returning `shared_ptr`.

[import ../examples/shared_ptr.cpp]

[sharedptr_normal]

[endsect]

[section Deleter]

`shared_ptr` can use a custom deleter.

[sharedptr_deleter]

[endsect]

[section Avoiding Leaks]
It is important not to create possible leaks, even with `shared_ptr`. 

[sharedptr_wrong]

The correct solution is to use another function that is evaluated first.

[sharedptr_make]

[note This is also an opportunity for optimzation. The allocated object
and the counter of the `shared_ptr` can be put into the same memory block.]

[endsect]

[section Casts]

Like `boost::shared_ptr` fcppt provides cast wrappers for `shared_ptr`.

[sharedptr_cast]

[endsect]

[endsect]

[section scoped_ptr]

`fcppt::scoped_ptr` is a new class that takes its deleter as a template template parameter as well.

[import ../examples/scoped_ptr.cpp]

[scopedptr]

[endsect]

[section weak_ptr]

`fcppt::weak_ptr` can be used to refer to an `fcppt::shared_ptr`
without taking ownership. This can be used to know whether a
`shared_ptr` is still alive or not.
In order to be consistent with `fcppt::shared_ptr`,
`fcppt::weak_ptr` uses a custom deleter as a template template parameter as well.

[import ../examples/weak_ptr.cpp]

[weakptr]

[endsect]

[section unique_ptr]

`fcppt::unique_ptr` is a C++03 emulation of the upcoming `std::unique_ptr`.
In a sense `unique_ptr` is similar to `auto_ptr` that only one instance can actually have ownership,
unlike `shared_ptr` which can have multiple. However, `auto_ptr` isn't movable but `unique_ptr` is.
What this means is that you can transfer ownership from one `unique_ptr` to another by moving it,
and not relying on some hacks that `auto_ptr` implements for that.
(Well, in C++03 a `unique_ptr` implementation is basically a hack as well but it can be done to behave
almost exactly as its C++0x counterpart.)

[note
`unique_ptr` also has the ability to use a custom deleter. This also implies that the
type it deletes has to be complete. `std::auto_ptr` doesn't require this at compile time and
produces undefined behaviour instead, which can be very hard to find.]

`unique_ptr` distinguishes two different cases where a move can happen, namely from an rvalue and
from an lvalue.
First, let's see how to return a `unique_ptr` from a function.

[import ../examples/unique_ptr.cpp]

[unique_ptr_factory]

A `unique_ptr` can be directly returned if it is an rvalue like in `int_ptr_factory`.
Notice the use of `make_unique_ptr` that is similar to `make_shared_ptr`.

If you already have an lvalue of a `unique_ptr` you have to call move to turn the
lvalue into an rvalue, like it is shown in the next example.

[unique_ptr_move]

`fcppt::shared_ptr` and `fcppt::scoped_ptr` both have the ability to take
the ownership from a `unique_ptr`.
The next example focuses on converting a `unique_ptr` to a `shared_ptr`.

[unique_ptr_shared_ptr]

[endsect]

[xinclude doxygen_smartpointers.xml]

[endsect]
