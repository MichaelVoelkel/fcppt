[section Chrono]

[section Introduction]

Chrono is an implementation of the upcoming C++ standard's `std::chrono`.
It provides roughly three different families of classes/templates:

[variablelist
[[duration]
[
`fcppt::chrono::duration` is a template class that represents a span in time
between two `time_point`s.
]]

[[time_point]
[
`fcppt::chrono::time_point` is a template class that represents a given point in time.
Its template parameters are its associated clock and a duration.
Two time_points can be subtracted to yield a duration.
Also a time_point has the `time_since_epoch()` function that returns a duration
that represents a time span starting at the clock's absolute offset.
]]

[[clocks]
[
`fcppt::chrono::system_clock`, `fcppt::chrono::steady_clock` and `fcppt::chrono::high_resolution_clock`
are the three clock classes provided by fcppt. They all have a static function called `now()` that
returns the current point in time. All of the three serve different purposes.
]]
]

[endsect]

[section Durations]

A duration is a template class that represents a span in time.
It has two template parameters:

* The underlying type the value is saved as,
* A ratio that tells how the value is to be interpreted.

[import ../examples/chrono/duration.cpp]

Here is an example for a duration counting in milliseconds.

[note This is just for exposition. `fcppt::chrono::milliseconds`
already exists, and you don't have to typedef milliseconds
yourself.]

[chrono_duration_decl]

Two durations can be converted using `duration_cast`.

[chrono_duration_convert]

A duration has a `count()` function that returns its internal
representation. This is most useful if you have to do
additional calculations on a duration.

[chrono_duration_count]

[endsect]

[section Time Points]

A time point is a template class that represents a point in time.
It has two template parameters:

* The clock the `time_point` belongs to.
* An associated duration.

Time points aren't very useful on their own, because they should
be obtained from a clock and not constructed directly.
Therefore the following examples use a hidden function `obtain_time_point`
to illustrate their use.

Time points can be subtracted to yield a duration.

[import ../examples/chrono/time_point.cpp]

[chrono_time_point_subtract]

Time points can also be converted using `time_point_cast`,
This is, however, seldomly needed.
[note You have to cast to the destination duration, because you should
not change the clock types of time points.]

[chrono_time_point_convert]

An absolute offset can be obtained using the `time_since_epoch()` function.
This offset represents a duration from the start of the associated clock.

[chrono_time_point_epoch]

[endsect]

[section Clocks]

Each of the three clocks has a common set of functions and typedefs:
[variablelist
[[`time_point`][The `time_point` associated with the clock]]
[[`now()`][Returns the current `time_point`]]
[[`is_steady`][A boolean constant that tells if this clock is steady]]
]

[section system_clock]

This clock can be used to measure system time.
System time is the time usually displayed to the user when they
watch the system clock or type commands such as 'date'.
[note Beware that the system time can change in unpredictable ways.
For example daylight-savings time might come into effect or the user
or a date client might change it.
It is therefore not recommended to use this clock to measure
time differences (like it is needed for a timer).]
For compatibility to the C standard library, a system clock's
time_point can be converted to and from `std::time_t`.

[import ../examples/chrono/system_clock.cpp]
[chronosystemclock]

[endsect]

[section steady_clock]
A steady clock is guaranteed to only produce increasing time_points
when time advances. This means two calls to its `now()` function:
``t1 = steady_clock::now(); t2 = steady_clock::now()`` will guarantee
that `t2` is always equal to or greater than `t1`.
[note This cannot be true for time points far in the future, as a computer is a finite machine.
But the time span is guaranteed to be large, like hundreds of years.]
This clock was previously called `monotonic_clock`. It got its new name `steady_clock`
with the additional semantic that it may not be adjusted which means that time between
clock ticks is constant.
Steady clocks are the only sensible choice if you want to implement a timer.
[note Apart from implementing a timer, the time_points produced by a steady clock have
no particular meaning. Usually an operating system will start the clock at 0 when it is started.
]

[import ../examples/chrono/steady_clock.cpp]
[chronosteadyclock]

[endsect]

[section high_resolution_clock]
`high_resolution_clock` is the third of the three clocks. Its purpose is to provide
the clock with the highest resolution possible, but it is not guaranteed to be steady.
If you want to use this clock as a timer instead, check if `high_resolution_clock::is_steady` is true.

[endsect]

[endsect]

[section asio support]

`boost::asio` needs various timing functionalities and by default it uses `boost.date_time`.
Fortunately, asio uses a template called `boost::asio::time_traits` that can be specialized
to allow different timing facilities to be used. The specialization for `fcppt::chrono`
can be found in `<fcppt/chrono/asio/time_traits.hpp>`.

Furthermore, fcppt provides a typedef `fcppt::chrono::asio::deadline_timer` and a few
helper functions to call its member functions with arbitrary durations or time_points.

[import ../examples/chrono/asio.cpp]

[endsect]

[xinclude doxygen_chrono.xml]

[endsect]
