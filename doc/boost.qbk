[section boost replacements]

[section noncopyable]
boost provides `boost::noncopyable` but it requires
that you either derive from it or aggregate it as a member.
Deriving can lead to conversion to `boost::noncopyable` by accident
or it can generate spurious warnings if you derive more than once
in a hierarchy.
Aggregating it as a member is also a bad idea because the empty base class optimization
cannot be used anymore and `boost::noncopyable` will take up at least one byte.
fcppt instead provides the macro `FCPPT_NONCOPYABLE`.
[note Because the macro has to make the copy constructor and the assignment operator
inaccessible, it will leave a private: scope after its declaration.]

[import ../examples/noncopyable.cpp]

[noncopyable]

There is also `FCPPT_NONASSIGNABLE` that just makes the assignment operator inaccessible.

[xinclude doxygen_noncopyable.xml]

[endsect]

[section Signals]

[section Motivation]

boost provides `boost::signal` for handling signals. The library has two problems, one minor and one major one. The minor one is: It doesn't live inside a namespace but in the "almost global" boost namespace. The major issue is: It's incredibly slow! [footnote Citation needed] Benchmarking a large library revealed that most of the performance goes into calling the boost signals. The same code with `fcppt::signal` had a significant performance advantage. So if you've been using boost::signal in performance critical code and your debugger indicates that the signal functions are indeed called often you might consider using `fcppt::signal` instead. A small example shows its usage:

[import ../examples/signals_simple.cpp]
[signals_simple]

[endsect]

[section Combiners]

Signals can have return values. If you attach more than one callback to such a signal, one has to have a way of combining the return values of the callbacks to one single return value. This is archieved with what we call "combiners". A signal can have only one combiner. If you do not supply one, a default combiner is used. So what does a combiner do? Let's say the function of the signal has return type `T`. Then the combiner function has the signature: `T (T,T)`, so it gets two return values and returns another one. When invoking a signal with a return type, one of the following is returned:

# If the signal doesn't have any callbacks registered, `T()` (the default-constructed return type) is returned.
# If it has exactly one callback, let's call it `f`, attached, then the result of `f()` is returned.
# Otherwise, the return value of the first callback is combined with the result of the second callback. The result of this computation is stored: `T temp = combiner(first_callback(),second_callback());`. This variable `temp` is then combined with the return value of the next callback: `T temp2 = combiner(temp,next_callback())` and so on. This is what functional languages call /folding/ (see [@http://en.wikipedia.org/wiki/Fold_(higher-order_function) this Wikipedia entry] for more information).

Here is an example:

[import ../examples/signals_combine.cpp]
[signals_combine]

Note the use of `fcppt::signal::connection_manager`. This is a simple class to aggregate connections so you don't have to declare `scoped_connection connection1,connection2,connection3,...;`

[endsect]

[xinclude doxygen_signal.xml]

[endsect]

[section Optional]
`fcppt::optional` is a replacement for `boost::optional`.
It simply doesn't use an undefined union trick. If boost stops doing that,
we might consider to use `boost::optional` again.

An optional, unlike a pointer, holds its optional object by value.
This also means that an optional has an additional size overhead if the value
is actually absent, but it doesn't require free store.

[import ../examples/optional.cpp]

[optional]

[xinclude doxygen_optional.xml]

[endsect]

[section Variant]
`fcppt::variant` is a replacement for `boost::variant`.
Unlike `boost::variant` it also doesn't use an undefined union trick.
There are, however, several other differences.

* Proper seperation of the headers. Each functionality resides in its own header file.
* `fcppt::variant::object` can be empty. It doesn't require its first type to be default constructible.
* `fcppt::variant` reuses `boost::mpl sequences` to abstract the types that it can hold, so we have less code duplication.
* A ternany visitation is supplied. The whole visitation algorithms could be refactored to be n-ary, but a ternany
  visitation already has severe impact on compile time.

[section A simple example]

[import ../examples/variant.cpp]

[variant]

[endsect]

[section A recursive variant]

Like `boost::variant` fcppt provides a wrapper for a recursive variant.
If a variant can (indirectly) hold itself again, a problem arises.
The variant class has to know all of its members' sizes. But until the variant
is completely declared, the size of itself cannot be known.
To remedy this situation, you have to wrap a variant inside a struct,
which in turn has to be wrapped inside `fcppt::variant::recursive`.
Almost all algorithms on a variant will behave as if the `recursive` struct isn't there.

[import ../examples/recursive_variant.cpp]

[recursivevariant]

[endsect]

[xinclude doxygen_variant.xml]

[endsect]

[endsect]
