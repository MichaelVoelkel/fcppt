[section Container]

[section tree]

[section Rationale]

An `fcppt::container::tree::object<T>` is a container modeling an n-ary tree holding objects of type `T`.
It has a /value/ of type `T` and /children/ of type `fcppt::container::tree::object<T>`.
[note Because of the inherent recursive property of the tree, it has to store its children in a `boost::ptr_list` which might make tree a bit heavy to include.
Consider using forward declarations where possible: `#include <fcppt/container/tree/object_fwd.hpp>`]

It tries to mimic the sequence containers from the standard library.
Also, its implementation is minimal in the sense that everything but trivial operations are outsourced to external headers -
the pre order traversal below is an example of this.
Most of the operations are self-explanatory. Here is a small example of the tree:

[import ../examples/container/tree_simple.cpp]
[tree_simple]

Note also that all operations which implicitly depend on a parent being present are undefined if `has_parent()` returns false.
The same goes for all operations which depend on at least one child being present and `empty()` returning true.

[endsect]

[section Iterators/Traversals]

The tree uses a `boost::ptr_list` to store its children, so the iterator guarantees are the same as for this container
(see [@http://www.boost.org/doc/libs/release/libs/ptr_container/doc/ptr_list.html here]).
Apart from using the traditional iteration methods -- using `begin(), end(), rbegin(), rend()` --
there are external traversal classes.
Those are best explained using a little example:

[import ../examples/container/tree_traversal.cpp]
[tree_traversal]

This will output

``
hello
foo
qux
bar
baz
``

[endsect]

[section Noncopyable Semantics]

We already mentioned `boost::ptr_list` which is designed to store
values by pointer and to have ownership at the same time.
This is useful for values that are not copyable, for example.
`fcppt::container::tree::object` also supports this.
Instead of writing `fcppt::container::tree::object<T>` you can say
`fcppt::container::tree::object<fcppt::container::tree::ptr_value<T> >`
which turns the tree into a ptr_container.
A `tree::object<ptr_value<T> > ` will have the following changes from a normal tree:

* All arguments of values it expects are `fcppt::unique_ptr<T>`.
* The internal type is an `fcppt::scoped_ptr<T>`.

It is also possible to release the held `scoped_ptr`
with `fcppt::container::tree::release`.

[import ../examples/container/tree_ptr.cpp]

[tree_ptr]

[endsect]

[xinclude doxygen_container_tree.xml]

[endsect]

[section bitfield]

[section Rationale]

Sometimes you want an enumeration which can take multiple values at once -
for orthogonal options like "a person can be hungry and tired,
not hungry and tired, hungry and not tired or not hungry and not tired".
An obvious solution is using the bit representation of an enumeration:

``
enum person_status
{
	hungry = 1,
	tired = 1 << 1,
	// insert more options here
};
``

This is tiresome (!) to write and also a little dangerous since the underlying type of an enumeration can only be an integral type. This means that you rely upon the fact that you have enough bits available on the target machine -- which might not always be true. Think about a bit field which has more than 64 bits.

`fcppt::container::bitfield::basic<Enum,Size>` is a template which remedies the situation. It's based on an enumeration `Enum` which satisfies the following requirements:

# Enum shall be an enumeration type that doesn't contain any enumerators with explicit values. Thus: `enum my_enum { value1, value2, value3 };` is perfectly valid while `enum my_enum { value = 100 };` is NOT valid.
# Size shall be the number of enumerators defined in Enum. To achieve consistency you should define the enum's size within the enum itself. Example: `enum my_enum { value1, value2, value3, _my_enum_size }; typedef bitfield::basic<my_enum,_my_enum_size> mybasic;`
# `operator|(Enum,Enum)` shall not be declared!

A small example shows how it's used:

[import ../examples/container/bitfield.cpp]
[bitfield]

As you can see, you can treat a `bitfield` like an integral type -- it has the
bitwise `operator&, operator|` and so on. But you can also treat it like a
`std::map<Enum,bool>` and access elements like that. You could even iterate
through the `bitfield` like a container (if you like).

[endsect]

[xinclude doxygen_container_bitfield.xml]

[endsect]

[section raw_vector]

Unlike `std::vector`, `fcppt::container::raw_vector` can only be used with POD
types and can leave its elements uninitialized.  Consider the following: You
want to read a number of bytes from an external source but you know that the
function doesn't care if you have initialized them before reading.

[caution Reading access to uninitialized elements of `raw_vector` is undefined
behavior. You have to write the elements before reading them.]

[import ../examples/container/raw_vector.cpp]

[rawvector]

Apart from the special constructor that leaves the elements uninitialized and a
few special functions, `fcppt::container::raw_vector` is like `std::vector`.

[xinclude doxygen_container_raw_vector.xml]

[endsect]

[section grid]

`fcppt::container::grid` is a simple multi dimensional array similar to `boost::multi_array`.
Let's first take a look at how to use a simple three dimensional grid of ints.

[import ../examples/container/grid.cpp]

[grid_simple]

Grid uses `fcppt::math::dim` to specify its size and to obtain an element.

[caution Grid tries to be as efficient as possible and won't necessarily initialize its elements.]

To resize a grid there are a couple of options.
`grid::object::resize` will resize the underlying container but leave
the elements of the grid in an unspecific state.
There are two functions to preserve the current elements that will still fit into the grid
after the resize: `resize_preserve` and `resize_preserve_init`.
`resize_preserve` only preserves the elements that still fit but doesn't initialize new elements.
`resize_preserve_init` is like `resize_preserve` but will give all new elements a default value.

[grid_resize]

Grid also offers a `data` function to access the underlying data by pointer.

[xinclude doxygen_container_grid.xml]

[endsect]

[section array]

`fcppt::container::array` is a class like the upcoming `std::array`.
It is important to note that `array` is a POD which means that it especially
has no constructors or private data members.

[import ../examples/container/array.cpp]

[array]

In addition to the new C++0x functionality, `fcppt::container::array` also
has a `data()` function to access the array directly via a pointer.

[xinclude doxygen_container_array.xml]

[endsect]

[section ptr_container helpers]

`boost.ptr_container` is a library that provides containers like
the stdlib does but they instead hold pointers to elements and take ownership
over the objects pointed to. This library is very useful for all sorts
of cases where a normal container from the stdlib cannot work.
The container requirements say that a type that should be stored inside a container
must fullfil the CopyConstructible and
Assignable concepts which means that a copy constructor must be accessible,
`&value` must yield the address of `value`, and an assignment operator must also be accessible.
This obviously limits the use of types that can be used with stdlib containers.

`fcppt::container::ptr` has some helper functions that make working especially
with `fcppt::unique_ptr` and boost.ptr_container easier.
Here is a quick example on how to insert a `unique_ptr` into a `ptr_map`.

[import ../examples/container/ptr.cpp]

[container_ptr]

[xinclude doxygen_container_ptr.xml]

[endsect]

[xinclude doxygen_container.xml]

[endsect]
