[section Container]

[section tree]

[section Rationale]

An `fcppt::container::tree::object<T>` is a container modeling an n-ary tree holding objects of type `T`. It has a /value/ of type `T` and /children/ of type `fcppt::container::tree::object<T>`. [note Because of the inherent recursive property of the tree, it has to store its children in a boost::ptr_container which might make tree a bit heavy to include. Consider using forward declarations where possible: `#include <fcppt/container/tree/object_fwd.hpp>`]

It tries to mimic the sequence and set container from the standard library. Also, its implementation is minimal in the sense that everything but trivial operations are outsourced to external headers - the traversal iterators below are an example of this. Most of the operations are self-explanatory. Here is a small example of the tree:

[import ../examples/tree_simple.cpp]
[tree_simple]

Note also that all operations which implicitly depend on a parent being present are undefined if `has_parent()` returns false. The same goes for all operations which depend on at least one child being present and `empty()` returning true.

[endsect]

[section Iterators/Traversals]

The tree uses a `boost::ptr_list` to store its children, so the iterator guarantees are the same as with this container (see [@http://www.boost.org/doc/libs/release/libs/ptr_container/doc/ptr_list.html here]). Apart from using the traditional iteration methods -- using `begin(), end(), rbegin(), rend()` -- there are external traversal classes. Those are best explained using a little example:

[import ../examples/tree_traversal.cpp]
[tree_traversal]

This will output 

``
hello
foo
qux
bar
baz
``

[endsect]

[section Synopsis]

[import ../include/fcppt/container/tree/object_decl.hpp]
[tree]

[endsect]


[endsect]

[section bitfield]

[section Rationale]

Sometimes you want an enumeration which can take multiple values at once -- for orthogonal options like "a person can be hungry and tired, not hungry and tired, hungry and not tired or not hungry and not tired". An obvious solution is using the bit representation of an enumeration:

``
enum person_status
{
	hungry = 1,
	tired = 1 << 1,
	// insert more options here
};
``

This is tiresome (!) to write and also a little dangerous since the underlying type of an enumeration can only be an integral type. This means that you rely upon the fact that you have enough bits available on the target machine -- which might not always be true. Think about a bit field which has more than 64 bits.

`fcppt::container::bitfield::basic<Enum,Size>` is a template which remedies the situation. It's based on an enumeration `Enum` which satisfies the following requirements:

# Enum shall be an enumeration type that doesn't contain any enumerators with explicit values. Thus: `enum my_enum { value1, value2, value3 };` is perfectly valid while `enum my_enum { value = 100 };` is NOT valid.
# Size shall be the number of enumerators defined in Enum. To achieve consistency you should define the enum's size within the enum itsself. Example: `enum my_enum { value1, value2, value3, _my_enum_size }; typedef bitfield::basic<my_enum,_my_enum_size> mybasic;`
# `operator|(Enum,Enum)` shall not be declared!

A small example shows how it's used:

[import ../examples/bitfield.cpp]
[bitfield]

As you can see, you can treat a bitfield like an integral type -- it has the bitwise `operator&, operator|` and so on. But you can also treat it like a `std::map<Enum,bool>` and access elements like that. You could even iterate through the bitfield like a container (if you like).

[endsect]

[section Synopsis]

[import ../include/fcppt/container/bitfield/basic_decl.hpp]
[bitfield_decl]

[endsect]

[endsect]

[section field]

[section Rationale]

An `fcppt::container::field<ArrayType>` is just a wrapper around a one-dimensional array `ArrayType` to make it act as a two-dimensional array.

[warning This class is a likely candidate for being rewritten in the future since it's only two-dimensinoal (not n-dimensional) and it's too monolithic. Use with caution.]

[endsect]

[section Synopsis]

[import ../include/fcppt/container/field_decl.hpp]
[field_decl]

[endsect]


[endsect]

[section linear_map/linear_set]

The standard library offers the classes `std::map<T>` and `std::set<T>`. The elements in these containers are ordered and are internally stored as a tree (or some other data structure that guarantees logarithmic access times). This ensures high access times when enough elements are stored in the map. With a very small amount of elements, however, a linear solution outperforms the standard library containers [footnote Citation needed]. Because of this, there are `fcppt::container::linear_map<T>` and `fcppt::container::linear_set<T>` which expose the /same/ interface as the standard library containers, but with different guarantees, since they store the elements in a `std::list`.

[endsect]

[section raw_vector]

TODO

[endsect]

[section map]

TODO

[endsect]

[endsect]
